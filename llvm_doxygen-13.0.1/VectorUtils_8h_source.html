<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: include/llvm/Analysis/VectorUtils.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLVM
   &#160;<span id="projectnumber">13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_dcde91663b8816e1e2311938ccd8f690.html">llvm</a></li><li class="navelem"><a class="el" href="dir_97cdd6ae7e6843add574fb55e792badd.html">Analysis</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">VectorUtils.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="VectorUtils_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//===- llvm/Analysis/VectorUtils.h - Vector utilities -----------*- C++ -*-===//</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">// See https://llvm.org/LICENSE.txt for license information.</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">// This file defines some vectorizer utilities.</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160; </div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="preprocessor">#ifndef LLVM_ANALYSIS_VECTORUTILS_H</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="preprocessor">#define LLVM_ANALYSIS_VECTORUTILS_H</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160; </div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="MapVector_8h.html">llvm/ADT/MapVector.h</a>&quot;</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="SmallVector_8h.html">llvm/ADT/SmallVector.h</a>&quot;</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="LoopAccessAnalysis_8h.html">llvm/Analysis/LoopAccessAnalysis.h</a>&quot;</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="CheckedArithmetic_8h.html">llvm/Support/CheckedArithmetic.h</a>&quot;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160; </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespacellvm.html">llvm</a> {</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="keyword">class </span>TargetLibraryInfo;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment">/// Describes the type of Parameters</span></div>
<div class="line"><a name="l00025"></a><span class="lineno"><a class="line" href="namespacellvm.html#add480f2ed87faa59c16d4c01ffb4bf39">   25</a></span>&#160;<span class="comment"></span><span class="keyword">enum class</span> <a class="code" href="namespacellvm.html#add480f2ed87faa59c16d4c01ffb4bf39">VFParamKind</a> {</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  <a class="code" href="namespacellvm.html#add480f2ed87faa59c16d4c01ffb4bf39a57dea6f5039281b7fee517fc43bf3110">Vector</a>,            <span class="comment">// No semantic information.</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  OMP_Linear,        <span class="comment">// declare simd linear(i)</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  OMP_LinearRef,     <span class="comment">// declare simd linear(ref(i))</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  OMP_LinearVal,     <span class="comment">// declare simd linear(val(i))</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  OMP_LinearUVal,    <span class="comment">// declare simd linear(uval(i))</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  OMP_LinearPos,     <span class="comment">// declare simd linear(i:c) uniform(c)</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  OMP_LinearValPos,  <span class="comment">// declare simd linear(val(i:c)) uniform(c)</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  OMP_LinearRefPos,  <span class="comment">// declare simd linear(ref(i:c)) uniform(c)</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  OMP_LinearUValPos, <span class="comment">// declare simd linear(uval(i:c)) uniform(c)</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  OMP_Uniform,       <span class="comment">// declare simd uniform(i)</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  GlobalPredicate,   <span class="comment">// Global logical predicate that acts on all lanes</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;                     <span class="comment">// of the input and output mask concurrently. For</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;                     <span class="comment">// example, it is implied by the `M` token in the</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;                     <span class="comment">// Vector Function ABI mangled name.</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <a class="code" href="namespacellvm.html#add480f2ed87faa59c16d4c01ffb4bf39a88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;};</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="comment">/// Describes the type of Instruction Set Architecture</span></div>
<div class="line"><a name="l00044"></a><span class="lineno"><a class="line" href="namespacellvm.html#abe2c24a8dc2fb979e8e54e15f088169c">   44</a></span>&#160;<span class="comment"></span><span class="keyword">enum class</span> <a class="code" href="namespacellvm.html#abe2c24a8dc2fb979e8e54e15f088169c">VFISAKind</a> {</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  AdvancedSIMD, <span class="comment">// AArch64 Advanced SIMD (NEON)</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  SVE,          <span class="comment">// AArch64 Scalable Vector Extension</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;  SSE,          <span class="comment">// x86 SSE</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  <a class="code" href="namespacellvm.html#abe2c24a8dc2fb979e8e54e15f088169ca4863502abea45861b9ed022e66d66cb2">AVX</a>,          <span class="comment">// x86 AVX</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  <a class="code" href="namespacellvm.html#abe2c24a8dc2fb979e8e54e15f088169caee6ecd3e091cdefd02e783f9b9869388">AVX2</a>,         <span class="comment">// x86 AVX2</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  AVX512,       <span class="comment">// x86 AVX512</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  <a class="code" href="Relocation_8txt.html#ad0265f082d0dc86496888b7cec1b717d">LLVM</a>,         <span class="comment">// LLVM internal ISA for functions that are not</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  <span class="comment">// attached to an existing ABI via name mangling.</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  <a class="code" href="namespacellvm.html#abe2c24a8dc2fb979e8e54e15f088169ca88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a> <span class="comment">// Unknown ISA</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;};</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment">/// Encapsulates information needed to describe a parameter.</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment">/// The description of the parameter is not linked directly to</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment">/// OpenMP or any other vector function description. This structure</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment">/// is extendible to handle other paradigms that describe vector</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment">/// functions and their parameters.</span></div>
<div class="line"><a name="l00062"></a><span class="lineno"><a class="line" href="structllvm_1_1VFParameter.html">   62</a></span>&#160;<span class="comment"></span><span class="keyword">struct </span><a class="code" href="structllvm_1_1VFParameter.html">VFParameter</a> {</div>
<div class="line"><a name="l00063"></a><span class="lineno"><a class="line" href="structllvm_1_1VFParameter.html#a967df74e8d0246a66ca1a27ba50daa8a">   63</a></span>&#160;  <span class="keywordtype">unsigned</span> <a class="code" href="structllvm_1_1VFParameter.html#a967df74e8d0246a66ca1a27ba50daa8a">ParamPos</a>;         <span class="comment">// Parameter Position in Scalar Function.</span></div>
<div class="line"><a name="l00064"></a><span class="lineno"><a class="line" href="structllvm_1_1VFParameter.html#a8c8f86edc9db58476d6b16903cd403ac">   64</a></span>&#160;  <a class="code" href="namespacellvm.html#add480f2ed87faa59c16d4c01ffb4bf39">VFParamKind</a> <a class="code" href="structllvm_1_1VFParameter.html#a8c8f86edc9db58476d6b16903cd403ac">ParamKind</a>;     <span class="comment">// Kind of Parameter.</span></div>
<div class="line"><a name="l00065"></a><span class="lineno"><a class="line" href="structllvm_1_1VFParameter.html#a55f4f41d21dba4ac5064e0b93224a4bf">   65</a></span>&#160;  <span class="keywordtype">int</span> <a class="code" href="structllvm_1_1VFParameter.html#a55f4f41d21dba4ac5064e0b93224a4bf">LinearStepOrPos</a> = 0;   <span class="comment">// Step or Position of the Parameter.</span></div>
<div class="line"><a name="l00066"></a><span class="lineno"><a class="line" href="structllvm_1_1VFParameter.html#a94f0b487dcd5db6130afd9ad8c46c091">   66</a></span>&#160;  <a class="code" href="structllvm_1_1Align.html">Align</a> <a class="code" href="structllvm_1_1VFParameter.html#a94f0b487dcd5db6130afd9ad8c46c091">Alignment</a> = <a class="code" href="ELFObjHandler_8cpp.html#a043cdaf7b89aaeeb127be5d93411637f">Align</a>(); <span class="comment">// Optional alignment in bytes, defaulted to 1.</span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160; </div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  <span class="comment">// Comparison operator.</span></div>
<div class="line"><a name="l00069"></a><span class="lineno"><a class="line" href="structllvm_1_1VFParameter.html#a7830a41f82d37336f5fe8d9d76638745">   69</a></span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="structllvm_1_1VFParameter.html#a7830a41f82d37336f5fe8d9d76638745">operator==</a>(<span class="keyword">const</span> <a class="code" href="structllvm_1_1VFParameter.html">VFParameter</a> &amp;Other)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="keywordflow">return</span> std::tie(<a class="code" href="structllvm_1_1VFParameter.html#a967df74e8d0246a66ca1a27ba50daa8a">ParamPos</a>, <a class="code" href="structllvm_1_1VFParameter.html#a8c8f86edc9db58476d6b16903cd403ac">ParamKind</a>, <a class="code" href="structllvm_1_1VFParameter.html#a55f4f41d21dba4ac5064e0b93224a4bf">LinearStepOrPos</a>, <a class="code" href="structllvm_1_1VFParameter.html#a94f0b487dcd5db6130afd9ad8c46c091">Alignment</a>) ==</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;           std::tie(<a class="code" href="ELFYAML_8cpp.html#a2a91b094e777dacc21de2a7f35da6805">Other</a>.ParamPos, <a class="code" href="ELFYAML_8cpp.html#a2a91b094e777dacc21de2a7f35da6805">Other</a>.ParamKind, <a class="code" href="ELFYAML_8cpp.html#a2a91b094e777dacc21de2a7f35da6805">Other</a>.LinearStepOrPos,</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                    <a class="code" href="ELFYAML_8cpp.html#a2a91b094e777dacc21de2a7f35da6805">Other</a>.Alignment);</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  }</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;};</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment">/// Contains the information about the kind of vectorization</span></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="comment">/// available.</span></div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="comment">/// This object in independent on the paradigm used to</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="comment">/// represent vector functions. in particular, it is not attached to</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="comment">/// any target-specific ABI.</span></div>
<div class="line"><a name="l00082"></a><span class="lineno"><a class="line" href="structllvm_1_1VFShape.html">   82</a></span>&#160;<span class="comment"></span><span class="keyword">struct </span><a class="code" href="structllvm_1_1VFShape.html">VFShape</a> {</div>
<div class="line"><a name="l00083"></a><span class="lineno"><a class="line" href="structllvm_1_1VFShape.html#a77688fcf1805363e5914276b0d491b63">   83</a></span>&#160;  <a class="code" href="classllvm_1_1ElementCount.html">ElementCount</a> <a class="code" href="structllvm_1_1VFShape.html#a77688fcf1805363e5914276b0d491b63">VF</a>;                        <span class="comment">// Vectorization factor.</span></div>
<div class="line"><a name="l00084"></a><span class="lineno"><a class="line" href="structllvm_1_1VFShape.html#a82591e3e596fe99aebc1e2f3316ef41c">   84</a></span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;VFParameter, 8&gt;</a> <a class="code" href="structllvm_1_1VFShape.html#a82591e3e596fe99aebc1e2f3316ef41c">Parameters</a>; <span class="comment">// List of parameter information.</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  <span class="comment">// Comparison operator.</span></div>
<div class="line"><a name="l00086"></a><span class="lineno"><a class="line" href="structllvm_1_1VFShape.html#aea3cb55414569157978afce988b13659">   86</a></span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="structllvm_1_1VFShape.html#aea3cb55414569157978afce988b13659">operator==</a>(<span class="keyword">const</span> <a class="code" href="structllvm_1_1VFShape.html">VFShape</a> &amp;Other)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="keywordflow">return</span> std::tie(<a class="code" href="structllvm_1_1VFShape.html#a77688fcf1805363e5914276b0d491b63">VF</a>, <a class="code" href="structllvm_1_1VFShape.html#a82591e3e596fe99aebc1e2f3316ef41c">Parameters</a>) == std::tie(<a class="code" href="ELFYAML_8cpp.html#a2a91b094e777dacc21de2a7f35da6805">Other</a>.VF, <a class="code" href="ELFYAML_8cpp.html#a2a91b094e777dacc21de2a7f35da6805">Other</a>.Parameters);</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  }</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="comment">  /// Update the parameter in position P.ParamPos to P.</span></div>
<div class="line"><a name="l00091"></a><span class="lineno"><a class="line" href="structllvm_1_1VFShape.html#a7ac579f061e62acfe262be1d1906eea2">   91</a></span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="structllvm_1_1VFShape.html#a7ac579f061e62acfe262be1d1906eea2">updateParam</a>(<a class="code" href="structllvm_1_1VFParameter.html">VFParameter</a> <a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>) {</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(<a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>.ParamPos &lt; <a class="code" href="structllvm_1_1VFShape.html#a82591e3e596fe99aebc1e2f3316ef41c">Parameters</a>.size() &amp;&amp; <span class="stringliteral">&quot;Invalid parameter position.&quot;</span>);</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <a class="code" href="structllvm_1_1VFShape.html#a82591e3e596fe99aebc1e2f3316ef41c">Parameters</a>[<a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>.ParamPos] = <a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>;</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(<a class="code" href="structllvm_1_1VFShape.html#a73ecf8e2dc91bc82db95710da747b5ab">hasValidParameterList</a>() &amp;&amp; <span class="stringliteral">&quot;Invalid parameter list&quot;</span>);</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  }</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160; </div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  <span class="comment">// Retrieve the VFShape that can be used to map a (scalar) function to itself,</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  <span class="comment">// with VF = 1.</span></div>
<div class="line"><a name="l00099"></a><span class="lineno"><a class="line" href="structllvm_1_1VFShape.html#a0ff6e282ab0c2d186052d7654441ada8">   99</a></span>&#160;  <span class="keyword">static</span> <a class="code" href="structllvm_1_1VFShape.html">VFShape</a> <a class="code" href="structllvm_1_1VFShape.html#a0ff6e282ab0c2d186052d7654441ada8">getScalarShape</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1CallInst.html">CallInst</a> &amp;CI) {</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structllvm_1_1VFShape.html#a33df83a8555fc8dd7c7d547576abb354">VFShape::get</a>(CI, <a class="code" href="classllvm_1_1LinearPolySize.html#afaf8f62538ab335bb4e3e08a1a57e27f">ElementCount::getFixed</a>(1),</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                        <span class="comment">/*HasGlobalPredicate*/</span> <span class="keyword">false</span>);</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  }</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160; </div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  <span class="comment">// Retrieve the basic vectorization shape of the function, where all</span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  <span class="comment">// parameters are mapped to VFParamKind::Vector with \p EC</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  <span class="comment">// lanes. Specifies whether the function has a Global Predicate</span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  <span class="comment">// argument via \p HasGlobalPred.</span></div>
<div class="line"><a name="l00108"></a><span class="lineno"><a class="line" href="structllvm_1_1VFShape.html#a33df83a8555fc8dd7c7d547576abb354">  108</a></span>&#160;  <span class="keyword">static</span> <a class="code" href="structllvm_1_1VFShape.html">VFShape</a> <a class="code" href="structllvm_1_1VFShape.html#a33df83a8555fc8dd7c7d547576abb354">get</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1CallInst.html">CallInst</a> &amp;CI, <a class="code" href="classllvm_1_1ElementCount.html">ElementCount</a> EC, <span class="keywordtype">bool</span> HasGlobalPred) {</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;VFParameter, 8&gt;</a> <a class="code" href="structllvm_1_1VFShape.html#a82591e3e596fe99aebc1e2f3316ef41c">Parameters</a>;</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> = 0; <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> &lt; CI.<a class="code" href="classllvm_1_1CallBase.html#adde2ea00dd2613ee41bfe91908e4e68e">arg_size</a>(); ++<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;      <a class="code" href="structllvm_1_1VFShape.html#a82591e3e596fe99aebc1e2f3316ef41c">Parameters</a>.push_back(<a class="code" href="structllvm_1_1VFParameter.html">VFParameter</a>({<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="code" href="namespacellvm.html#add480f2ed87faa59c16d4c01ffb4bf39a57dea6f5039281b7fee517fc43bf3110">VFParamKind::Vector</a>}));</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <span class="keywordflow">if</span> (HasGlobalPred)</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;      <a class="code" href="structllvm_1_1VFShape.html#a82591e3e596fe99aebc1e2f3316ef41c">Parameters</a>.push_back(</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;          <a class="code" href="structllvm_1_1VFParameter.html">VFParameter</a>({CI.<a class="code" href="classllvm_1_1CallBase.html#adde2ea00dd2613ee41bfe91908e4e68e">arg_size</a>(), VFParamKind::GlobalPredicate}));</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160; </div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    <span class="keywordflow">return</span> {EC, <a class="code" href="structllvm_1_1VFShape.html#a82591e3e596fe99aebc1e2f3316ef41c">Parameters</a>};</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  }<span class="comment"></span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment">  /// Sanity check on the Parameters in the VFShape.</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> <a class="code" href="structllvm_1_1VFShape.html#a73ecf8e2dc91bc82db95710da747b5ab">hasValidParameterList</a>() <span class="keyword">const</span>;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;};</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment">/// Holds the VFShape for a specific scalar to vector function mapping.</span></div>
<div class="line"><a name="l00123"></a><span class="lineno"><a class="line" href="structllvm_1_1VFInfo.html">  123</a></span>&#160;<span class="comment"></span><span class="keyword">struct </span><a class="code" href="structllvm_1_1VFInfo.html">VFInfo</a> {</div>
<div class="line"><a name="l00124"></a><span class="lineno"><a class="line" href="structllvm_1_1VFInfo.html#ad9bb08bdbfc73cf77e85c835840baf10">  124</a></span>&#160;  <a class="code" href="structllvm_1_1VFShape.html">VFShape</a> <a class="code" href="structllvm_1_1VFInfo.html#ad9bb08bdbfc73cf77e85c835840baf10">Shape</a>;          <span class="comment">/// Classification of the vector function.</span></div>
<div class="line"><a name="l00125"></a><span class="lineno"><a class="line" href="structllvm_1_1VFInfo.html#abfb66d9c1a71777713734b160cc4f0b5">  125</a></span>&#160;<span class="comment"></span>  std::string <a class="code" href="structllvm_1_1VFInfo.html#abfb66d9c1a71777713734b160cc4f0b5">ScalarName</a>; <span class="comment">/// Scalar Function Name.</span></div>
<div class="line"><a name="l00126"></a><span class="lineno"><a class="line" href="structllvm_1_1VFInfo.html#a87c240df9a221a4e18326c7adc599629">  126</a></span>&#160;<span class="comment"></span>  std::string <a class="code" href="structllvm_1_1VFInfo.html#a87c240df9a221a4e18326c7adc599629">VectorName</a>; <span class="comment">/// Vector Function Name associated to this VFInfo.</span></div>
<div class="line"><a name="l00127"></a><span class="lineno"><a class="line" href="structllvm_1_1VFInfo.html#aa8ab6db11ae7c0891185e2a2a1f338d5">  127</a></span>&#160;<span class="comment"></span>  <a class="code" href="namespacellvm.html#abe2c24a8dc2fb979e8e54e15f088169c">VFISAKind</a> <a class="code" href="structllvm_1_1VFInfo.html#aa8ab6db11ae7c0891185e2a2a1f338d5">ISA</a>;          <span class="comment">/// Instruction Set Architecture.</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="comment"></span>};</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160; </div>
<div class="line"><a name="l00130"></a><span class="lineno"><a class="line" href="namespacellvm_1_1VFABI.html">  130</a></span>&#160;<span class="keyword">namespace </span>VFABI {<span class="comment"></span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="comment">/// LLVM Internal VFABI ISA token for vector functions.</span></div>
<div class="line"><a name="l00132"></a><span class="lineno"><a class="line" href="namespacellvm_1_1VFABI.html#af33ac7943ba16e891cd1b6e307029301">  132</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> constexpr <span class="keywordtype">char</span> <span class="keyword">const</span> *<a class="code" href="namespacellvm_1_1VFABI.html#af33ac7943ba16e891cd1b6e307029301">_LLVM_</a> = <span class="stringliteral">&quot;_LLVM_&quot;</span>;<span class="comment"></span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="comment">/// Prefix for internal name redirection for vector function that</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="comment">/// tells the compiler to scalarize the call using the scalar name</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="comment">/// of the function. For example, a mangled name like</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="comment">/// `_ZGV_LLVM_N2v_foo(_LLVM_Scalarize_foo)` would tell the</span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="comment">/// vectorizer to vectorize the scalar call `foo`, and to scalarize</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="comment">/// it once vectorization is done.</span></div>
<div class="line"><a name="l00139"></a><span class="lineno"><a class="line" href="namespacellvm_1_1VFABI.html#a3b4aafd885099e61903f0a29e638a8b1">  139</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> constexpr <span class="keywordtype">char</span> <span class="keyword">const</span> *<a class="code" href="namespacellvm_1_1VFABI.html#a3b4aafd885099e61903f0a29e638a8b1">_LLVM_Scalarize_</a> = <span class="stringliteral">&quot;_LLVM_Scalarize_&quot;</span>;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="comment">/// Function to construct a VFInfo out of a mangled names in the</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="comment">/// following format:</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="comment">/// &lt;VFABI_name&gt;{(&lt;redirection&gt;)}</span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="comment">/// where &lt;VFABI_name&gt; is the name of the vector function, mangled according</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="comment">/// to the rules described in the Vector Function ABI of the target vector</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="comment">/// extension (or &lt;isa&gt; from now on). The &lt;VFABI_name&gt; is in the following</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="comment">/// format:</span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="comment">/// _ZGV&lt;isa&gt;&lt;mask&gt;&lt;vlen&gt;&lt;parameters&gt;_&lt;scalarname&gt;[(&lt;redirection&gt;)]</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="comment">/// This methods support demangling rules for the following &lt;isa&gt;:</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="comment">/// * AArch64: https://developer.arm.com/docs/101129/latest</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="comment">/// * x86 (libmvec): https://sourceware.org/glibc/wiki/libmvec and</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="comment">///  https://sourceware.org/glibc/wiki/libmvec?action=AttachFile&amp;do=view&amp;target=VectorABI.txt</span></div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="comment">/// \param MangledName -&gt; input string in the format</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="comment">/// _ZGV&lt;isa&gt;&lt;mask&gt;&lt;vlen&gt;&lt;parameters&gt;_&lt;scalarname&gt;[(&lt;redirection&gt;)].</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="comment">/// \param M -&gt; Module used to retrieve informations about the vector</span></div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="comment">/// function that are not possible to retrieve from the mangled</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="comment">/// name. At the moment, this parameter is needed only to retrieve the</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="comment">/// Vectorization Factor of scalable vector functions from their</span></div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="comment">/// respective IR declarations.</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="comment"></span><a class="code" href="classllvm_1_1Optional.html">Optional&lt;VFInfo&gt;</a> <a class="code" href="namespacellvm_1_1VFABI.html#a8f5eee7fb0b7a37cb4e8d68e2d1c1fe6">tryDemangleForVFABI</a>(<a class="code" href="classllvm_1_1StringRef.html">StringRef</a> MangledName, <span class="keyword">const</span> <a class="code" href="classllvm_1_1Module.html">Module</a> &amp;M);</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="comment">/// This routine mangles the given VectorName according to the LangRef</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="comment">/// specification for vector-function-abi-variant attribute and is specific to</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="comment">/// the TLI mappings. It is the responsibility of the caller to make sure that</span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="comment">/// this is only used if all parameters in the vector function are vector type.</span></div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="comment">/// This returned string holds scalar-to-vector mapping:</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="comment">///    _ZGV&lt;isa&gt;&lt;mask&gt;&lt;vlen&gt;&lt;vparams&gt;_&lt;scalarname&gt;(&lt;vectorname&gt;)</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="comment">/// where:</span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="comment">/// &lt;isa&gt; = &quot;_LLVM_&quot;</span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="comment">/// &lt;mask&gt; = &quot;N&quot;. Note: TLI does not support masked interfaces.</span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="comment">/// &lt;vlen&gt; = Number of concurrent lanes, stored in the `VectorizationFactor`</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="comment">///          field of the `VecDesc` struct. If the number of lanes is scalable</span></div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="comment">///          then &#39;x&#39; is printed instead.</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="comment">/// &lt;vparams&gt; = &quot;v&quot;, as many as are the numArgs.</span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="comment">/// &lt;scalarname&gt; = the name of the scalar function.</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="comment">/// &lt;vectorname&gt; = the name of the vector function.</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;<span class="comment"></span>std::string <a class="code" href="namespacellvm_1_1VFABI.html#a64353c34cb9dba37aa99ed7bbe63c903">mangleTLIVectorName</a>(<a class="code" href="classllvm_1_1StringRef.html">StringRef</a> VectorName, <a class="code" href="classllvm_1_1StringRef.html">StringRef</a> ScalarName,</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                                <span class="keywordtype">unsigned</span> numArgs, <a class="code" href="classllvm_1_1ElementCount.html">ElementCount</a> VF);</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment">/// Retrieve the `VFParamKind` from a string token.</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="comment"></span><a class="code" href="namespacellvm.html#add480f2ed87faa59c16d4c01ffb4bf39">VFParamKind</a> <a class="code" href="namespacellvm_1_1VFABI.html#aaf19acac548dca3c8f263ceb6a860b57">getVFParamKindFromString</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1StringRef.html">StringRef</a> Token);</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160; </div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="comment">// Name of the attribute where the variant mappings are stored.</span></div>
<div class="line"><a name="l00193"></a><span class="lineno"><a class="line" href="namespacellvm_1_1VFABI.html#a11875601ee512fa1f5cf6b6354c8def9">  193</a></span>&#160;<span class="keyword">static</span> constexpr <span class="keywordtype">char</span> <span class="keyword">const</span> *<a class="code" href="namespacellvm_1_1VFABI.html#a11875601ee512fa1f5cf6b6354c8def9">MappingsAttrName</a> = <span class="stringliteral">&quot;vector-function-abi-variant&quot;</span>;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="comment">/// Populates a set of strings representing the Vector Function ABI variants</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="comment">/// associated to the CallInst CI. If the CI does not contain the</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;<span class="comment">/// vector-function-abi-variant attribute, we return without populating</span></div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;<span class="comment">/// VariantMappings, i.e. callers of getVectorVariantNames need not check for</span></div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;<span class="comment">/// the presence of the attribute (see InjectTLIMappings).</span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;<span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="namespacellvm_1_1VFABI.html#a8adf44ad04562ff150b0e8e352a38d46">getVectorVariantNames</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1CallInst.html">CallInst</a> &amp;CI,</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                           <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;std::string&gt;</a> &amp;VariantMappings);</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;} <span class="comment">// end namespace VFABI</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="comment">/// The Vector Function Database.</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="comment">/// Helper class used to find the vector functions associated to a</span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="comment">/// scalar CallInst.</span></div>
<div class="line"><a name="l00208"></a><span class="lineno"><a class="line" href="classllvm_1_1VFDatabase.html">  208</a></span>&#160;<span class="comment"></span><span class="keyword">class </span><a class="code" href="classllvm_1_1VFDatabase.html">VFDatabase</a> {<span class="comment"></span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="comment">  /// The Module of the CallInst CI.</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classllvm_1_1Module.html">Module</a> *M;<span class="comment"></span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="comment">  /// The CallInst instance being queried for scalar to vector mappings.</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classllvm_1_1CallInst.html">CallInst</a> &amp;CI;<span class="comment"></span></div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="comment">  /// List of vector functions descriptors associated to the call</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="comment">  /// instruction.</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;VFInfo, 8&gt;</a> ScalarToVectorMappings;</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="comment">  /// Retrieve the scalar-to-vector mappings associated to the rule of</span></div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="comment">  /// a vector Function ABI.</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="comment"></span>  <span class="keyword">static</span> <span class="keywordtype">void</span> getVFABIMappings(<span class="keyword">const</span> <a class="code" href="classllvm_1_1CallInst.html">CallInst</a> &amp;CI,</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                               <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;VFInfo&gt;</a> &amp;<a class="code" href="InjectTLIMappings_8cpp.html#a3d23fb8c590cd607d4b25a05e31c69f5">Mappings</a>) {</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    <span class="keywordflow">if</span> (!CI.<a class="code" href="classllvm_1_1CallBase.html#a83b8c9e572130f403445c0b0f69b837c">getCalledFunction</a>())</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;      <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160; </div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    <span class="keyword">const</span> <a class="code" href="classllvm_1_1StringRef.html">StringRef</a> ScalarName = CI.<a class="code" href="classllvm_1_1CallBase.html#a83b8c9e572130f403445c0b0f69b837c">getCalledFunction</a>()-&gt;<a class="code" href="classllvm_1_1Value.html#adb5c319f5905c1d3ca9eb5df546388c5">getName</a>();</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160; </div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;std::string, 8&gt;</a> ListOfStrings;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    <span class="comment">// The check for the vector-function-abi-variant attribute is done when</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    <span class="comment">// retrieving the vector variant names here.</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    <a class="code" href="namespacellvm_1_1VFABI.html#a8adf44ad04562ff150b0e8e352a38d46">VFABI::getVectorVariantNames</a>(CI, ListOfStrings);</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    <span class="keywordflow">if</span> (ListOfStrings.empty())</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;      <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;MangledName : ListOfStrings) {</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;      <span class="keyword">const</span> <a class="code" href="classllvm_1_1Optional.html">Optional&lt;VFInfo&gt;</a> Shape =</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;          <a class="code" href="namespacellvm_1_1VFABI.html#a8f5eee7fb0b7a37cb4e8d68e2d1c1fe6">VFABI::tryDemangleForVFABI</a>(MangledName, *(CI.<a class="code" href="classllvm_1_1Instruction.html#a4ba3a5be6c0e9b9e8a525de055836733">getModule</a>()));</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;      <span class="comment">// A match is found via scalar and vector names, and also by</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;      <span class="comment">// ensuring that the variant described in the attribute has a</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;      <span class="comment">// corresponding definition or declaration of the vector</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;      <span class="comment">// function in the Module M.</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;      <span class="keywordflow">if</span> (Shape.<a class="code" href="classllvm_1_1Optional.html#ab8f06efe88f146384116a787058ab420">hasValue</a>() &amp;&amp; (Shape.<a class="code" href="classllvm_1_1Optional.html#a9ed8669536d806aff028d983595bab4d">getValue</a>().ScalarName == ScalarName)) {</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(CI.<a class="code" href="classllvm_1_1Instruction.html#a4ba3a5be6c0e9b9e8a525de055836733">getModule</a>()-&gt;<a class="code" href="classllvm_1_1Module.html#a209a615a3a32241323420cca24b5520a">getFunction</a>(Shape.<a class="code" href="classllvm_1_1Optional.html#a9ed8669536d806aff028d983595bab4d">getValue</a>().VectorName) &amp;&amp;</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;               <span class="stringliteral">&quot;Vector function is missing.&quot;</span>);</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;        <a class="code" href="InjectTLIMappings_8cpp.html#a3d23fb8c590cd607d4b25a05e31c69f5">Mappings</a>.push_back(Shape.<a class="code" href="classllvm_1_1Optional.html#a9ed8669536d806aff028d983595bab4d">getValue</a>());</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;      }</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    }</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;  }</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160; </div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="keyword">public</span>:<span class="comment"></span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="comment">  /// Retrieve all the VFInfo instances associated to the CallInst CI.</span></div>
<div class="line"><a name="l00249"></a><span class="lineno"><a class="line" href="classllvm_1_1VFDatabase.html#af9abb14ef675e9dee8dd14bd4dd43aac">  249</a></span>&#160;<span class="comment"></span>  <span class="keyword">static</span> <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;VFInfo, 8&gt;</a> <a class="code" href="classllvm_1_1VFDatabase.html#af9abb14ef675e9dee8dd14bd4dd43aac">getMappings</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1CallInst.html">CallInst</a> &amp;CI) {</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;VFInfo, 8&gt;</a> <a class="code" href="namespacellvm_1_1MipsISD.html#a422daf9aa810935178671306b651d69ba366e1eac31eeb1a1892d62ccfc0c8cf8">Ret</a>;</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160; </div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    <span class="comment">// Get mappings from the Vector Function ABI variants.</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    getVFABIMappings(CI, <a class="code" href="namespacellvm_1_1MipsISD.html#a422daf9aa810935178671306b651d69ba366e1eac31eeb1a1892d62ccfc0c8cf8">Ret</a>);</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160; </div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    <span class="comment">// Other non-VFABI variants should be retrieved here.</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160; </div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacellvm_1_1MipsISD.html#a422daf9aa810935178671306b651d69ba366e1eac31eeb1a1892d62ccfc0c8cf8">Ret</a>;</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;  }</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="comment">  /// Constructor, requires a CallInst instance.</span></div>
<div class="line"><a name="l00261"></a><span class="lineno"><a class="line" href="classllvm_1_1VFDatabase.html#a3881ccac8348749253e8d558a829cd21">  261</a></span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1VFDatabase.html#a3881ccac8348749253e8d558a829cd21">VFDatabase</a>(<a class="code" href="classllvm_1_1CallInst.html">CallInst</a> &amp;CI)</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;      : <a class="code" href="lib_2Target_2X86_2README_8txt.html#ac88fe1d3a61b056a4f64fbbb156a62ff">M</a>(CI.getModule()), CI(CI),</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        ScalarToVectorMappings(<a class="code" href="classllvm_1_1VFDatabase.html">VFDatabase</a>::<a class="code" href="classllvm_1_1VFDatabase.html#af9abb14ef675e9dee8dd14bd4dd43aac">getMappings</a>(CI)) {}<span class="comment"></span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="comment">  /// \defgroup VFDatabase query interface.</span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="comment">  ///</span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment">  /// @{</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment">  /// Retrieve the Function with VFShape \p Shape.</span></div>
<div class="line"><a name="l00268"></a><span class="lineno"><a class="line" href="group__VFDatabase.html#ga66862f50dead385e61e416b35110c5f1">  268</a></span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1Function.html">Function</a> *<a class="code" href="group__VFDatabase.html#ga66862f50dead385e61e416b35110c5f1">getVectorizedFunction</a>(<span class="keyword">const</span> <a class="code" href="structllvm_1_1VFShape.html">VFShape</a> &amp;Shape)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    <span class="keywordflow">if</span> (Shape == <a class="code" href="structllvm_1_1VFShape.html#a0ff6e282ab0c2d186052d7654441ada8">VFShape::getScalarShape</a>(CI))</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;      <span class="keywordflow">return</span> CI.<a class="code" href="classllvm_1_1CallBase.html#a83b8c9e572130f403445c0b0f69b837c">getCalledFunction</a>();</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160; </div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="CSEInfo_8cpp.html#a75f8a8519c2c9b30e7c06dc5e256fffa">Info</a> : ScalarToVectorMappings)</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="CSEInfo_8cpp.html#a75f8a8519c2c9b30e7c06dc5e256fffa">Info</a>.Shape == Shape)</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="lib_2Target_2X86_2README_8txt.html#ac88fe1d3a61b056a4f64fbbb156a62ff">M</a>-&gt;getFunction(<a class="code" href="CSEInfo_8cpp.html#a75f8a8519c2c9b30e7c06dc5e256fffa">Info</a>.VectorName);</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160; </div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;  }<span class="comment"></span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="comment">  /// @}</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="comment"></span>};</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160; </div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>ArrayRef;</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="keyword">class </span>DemandedBits;</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="keyword">class </span>GetElementPtrInst;</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> InstTy&gt; <span class="keyword">class </span>InterleaveGroup;</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="keyword">class </span>IRBuilderBase;</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="keyword">class </span>Loop;</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="keyword">class </span>ScalarEvolution;</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="keyword">class </span>TargetTransformInfo;</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="keyword">class </span><a class="code" href="namespacellvm_1_1msgpack.html#afdae9da66bac09f4b2bfc0fd9f0559e6">Type</a>;</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="keyword">class </span><a class="code" href="namespacellvm_1_1TargetStackID.html#a71392100eb15ba746b1f898986f5d8a5">Value</a>;</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160; </div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;<span class="keyword">namespace </span>Intrinsic {</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <a class="code" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">ID</a>;</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;}</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="comment">/// A helper function for converting Scalar types to vector types. If</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;<span class="comment">/// the incoming type is void, we return void. If the EC represents a</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;<span class="comment">/// scalar, we return the scalar type.</span></div>
<div class="line"><a name="l00299"></a><span class="lineno"><a class="line" href="namespacellvm.html#a273a0d00c32d9201b643a8e36822191c">  299</a></span>&#160;<span class="comment"></span><span class="keyword">inline</span> <a class="code" href="classllvm_1_1Type.html">Type</a> *<a class="code" href="namespacellvm.html#a273a0d00c32d9201b643a8e36822191c">ToVectorTy</a>(<a class="code" href="classllvm_1_1Type.html">Type</a> *<a class="code" href="namespacellvm_1_1NVPTX_1_1PTXLdStInstCode.html#a91119cbee2be000c528a690252aee07ca09c68d67f7dbfa6cc77eaf73aa535217">Scalar</a>, <a class="code" href="classllvm_1_1ElementCount.html">ElementCount</a> EC) {</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="namespacellvm_1_1NVPTX_1_1PTXLdStInstCode.html#a91119cbee2be000c528a690252aee07ca09c68d67f7dbfa6cc77eaf73aa535217">Scalar</a>-&gt;isVoidTy() || <a class="code" href="namespacellvm_1_1NVPTX_1_1PTXLdStInstCode.html#a91119cbee2be000c528a690252aee07ca09c68d67f7dbfa6cc77eaf73aa535217">Scalar</a>-&gt;isMetadataTy() || EC.<a class="code" href="classllvm_1_1ElementCount.html#add8ce9d6756a651e5f26d7c8c5796e2c">isScalar</a>())</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacellvm_1_1NVPTX_1_1PTXLdStInstCode.html#a91119cbee2be000c528a690252aee07ca09c68d67f7dbfa6cc77eaf73aa535217">Scalar</a>;</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1VectorType.html#a8c90e6c50e795b17466482a04947690e">VectorType::get</a>(<a class="code" href="namespacellvm_1_1NVPTX_1_1PTXLdStInstCode.html#a91119cbee2be000c528a690252aee07ca09c68d67f7dbfa6cc77eaf73aa535217">Scalar</a>, EC);</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;}</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160; </div>
<div class="line"><a name="l00305"></a><span class="lineno"><a class="line" href="namespacellvm.html#a27d7bd97f09d79673de229a5a61514c3">  305</a></span>&#160;<span class="keyword">inline</span> <a class="code" href="classllvm_1_1Type.html">Type</a> *<a class="code" href="namespacellvm.html#a273a0d00c32d9201b643a8e36822191c">ToVectorTy</a>(<a class="code" href="classllvm_1_1Type.html">Type</a> *<a class="code" href="namespacellvm_1_1NVPTX_1_1PTXLdStInstCode.html#a91119cbee2be000c528a690252aee07ca09c68d67f7dbfa6cc77eaf73aa535217">Scalar</a>, <span class="keywordtype">unsigned</span> VF) {</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacellvm.html#a273a0d00c32d9201b643a8e36822191c">ToVectorTy</a>(<a class="code" href="namespacellvm_1_1NVPTX_1_1PTXLdStInstCode.html#a91119cbee2be000c528a690252aee07ca09c68d67f7dbfa6cc77eaf73aa535217">Scalar</a>, <a class="code" href="classllvm_1_1LinearPolySize.html#afaf8f62538ab335bb4e3e08a1a57e27f">ElementCount::getFixed</a>(VF));</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;}</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="comment">/// Identify if the intrinsic is trivially vectorizable.</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;<span class="comment">/// This method returns true if the intrinsic&#39;s argument types are all scalars</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;<span class="comment">/// for the scalar form of the intrinsic and all vectors (or scalars handled by</span></div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;<span class="comment">/// hasVectorInstrinsicScalarOpd) for the vector form of the intrinsic.</span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<span class="comment"></span><span class="keywordtype">bool</span> <a class="code" href="namespacellvm.html#aeb65ce026673a69aac75e5a7a26007b3">isTriviallyVectorizable</a>(<a class="code" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">Intrinsic::ID</a> <a class="code" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">ID</a>);</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="comment">/// Identifies if the vector form of the intrinsic has a scalar operand.</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="comment"></span><span class="keywordtype">bool</span> <a class="code" href="namespacellvm.html#ae3bea22b27151dae0f6e4a00f71cf857">hasVectorInstrinsicScalarOpd</a>(<a class="code" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">Intrinsic::ID</a> <a class="code" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">ID</a>, <span class="keywordtype">unsigned</span> ScalarOpdIdx);</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;<span class="comment">/// Identifies if the vector form of the intrinsic has a scalar operand that has</span></div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;<span class="comment">/// an overloaded type.</span></div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;<span class="comment"></span><span class="keywordtype">bool</span> <a class="code" href="namespacellvm.html#abff3996076b4c76ea19757dc6853436e">hasVectorInstrinsicOverloadedScalarOpd</a>(<a class="code" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">Intrinsic::ID</a> <a class="code" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">ID</a>,</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;                                            <span class="keywordtype">unsigned</span> ScalarOpdIdx);</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="comment">/// Returns intrinsic ID for call.</span></div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="comment">/// For the input call instruction it finds mapping intrinsic and returns</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="comment">/// its intrinsic ID, in case it does not found it return not_intrinsic.</span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="comment"></span><a class="code" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">Intrinsic::ID</a> <a class="code" href="namespacellvm.html#a11c66d01880f53332fc7ad53f565b039">getVectorIntrinsicIDForCall</a>(<span class="keyword">const</span> CallInst *CI,</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                                          <span class="keyword">const</span> TargetLibraryInfo *TLI);</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="comment">/// Find the operand of the GEP that should be checked for consecutive</span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="comment">/// stores. This ignores trailing indices that have no effect on the final</span></div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="comment">/// pointer.</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="comment"></span><span class="keywordtype">unsigned</span> <a class="code" href="namespacellvm.html#ac099f60f123281d4abe0c1589c5f3812">getGEPInductionOperand</a>(<span class="keyword">const</span> GetElementPtrInst *Gep);</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="comment">/// If the argument is a GEP, then returns the operand identified by</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="comment">/// getGEPInductionOperand. However, if there is some other non-loop-invariant</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="comment">/// operand, it returns that instead.</span></div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;<span class="comment"></span><a class="code" href="namespacellvm_1_1TargetStackID.html#a71392100eb15ba746b1f898986f5d8a5">Value</a> *<a class="code" href="namespacellvm.html#a0bab12864bbc1f177e0999b0706bbcbb">stripGetElementPtr</a>(<a class="code" href="namespacellvm_1_1TargetStackID.html#a71392100eb15ba746b1f898986f5d8a5">Value</a> *Ptr, ScalarEvolution *SE, Loop *Lp);</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="comment">/// If a value has only one user that is a CastInst, return it.</span></div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="comment"></span><a class="code" href="namespacellvm_1_1TargetStackID.html#a71392100eb15ba746b1f898986f5d8a5">Value</a> *<a class="code" href="namespacellvm.html#a7f585f542b02a8f683f3df717d631755">getUniqueCastUse</a>(<a class="code" href="namespacellvm_1_1TargetStackID.html#a71392100eb15ba746b1f898986f5d8a5">Value</a> *Ptr, Loop *Lp, <a class="code" href="namespacellvm_1_1msgpack.html#afdae9da66bac09f4b2bfc0fd9f0559e6">Type</a> *Ty);</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="comment">/// Get the stride of a pointer access in a loop. Looks for symbolic</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="comment">/// strides &quot;a[i*stride]&quot;. Returns the symbolic stride, or null otherwise.</span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="comment"></span><a class="code" href="namespacellvm_1_1TargetStackID.html#a71392100eb15ba746b1f898986f5d8a5">Value</a> *<a class="code" href="namespacellvm.html#a611d9f877de3e9402bd8f56fb10ec5a1">getStrideFromPointer</a>(<a class="code" href="namespacellvm_1_1TargetStackID.html#a71392100eb15ba746b1f898986f5d8a5">Value</a> *Ptr, ScalarEvolution *SE, Loop *Lp);</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="comment">/// Given a vector and an element number, see if the scalar value is</span></div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<span class="comment">/// already around as a register, for example if it were inserted then extracted</span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="comment">/// from the vector.</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;<span class="comment"></span><a class="code" href="namespacellvm_1_1TargetStackID.html#a71392100eb15ba746b1f898986f5d8a5">Value</a> *<a class="code" href="namespacellvm.html#ab09fc7dee4f7e02c60f7a9c928dc1603">findScalarElement</a>(<a class="code" href="namespacellvm_1_1TargetStackID.html#a71392100eb15ba746b1f898986f5d8a5">Value</a> *V, <span class="keywordtype">unsigned</span> EltNo);</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="comment">/// If all non-negative \p Mask elements are the same value, return that value.</span></div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;<span class="comment">/// If all elements are negative (undefined) or \p Mask contains different</span></div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="comment">/// non-negative values, return -1.</span></div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;<span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="namespacellvm.html#afe8a7cc03eb7adf81589f0744e379f74">getSplatIndex</a>(ArrayRef&lt;int&gt; <a class="code" href="namespacellvm_1_1BitmaskEnumDetail.html#ad9273b0ee6c5e0f2367e3136c1503811">Mask</a>);</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;<span class="comment">/// Get splat value if the input is a splat vector or return nullptr.</span></div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;<span class="comment">/// The value may be extracted from a splat constants vector or from</span></div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="comment">/// a sequence of instructions that broadcast a single value into a vector.</span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="comment"></span><a class="code" href="namespacellvm_1_1TargetStackID.html#a71392100eb15ba746b1f898986f5d8a5">Value</a> *<a class="code" href="namespacellvm.html#a48fc95f799e976fb8bf571d61e6337f5">getSplatValue</a>(<span class="keyword">const</span> <a class="code" href="namespacellvm_1_1TargetStackID.html#a71392100eb15ba746b1f898986f5d8a5">Value</a> *V);</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;<span class="comment">/// Return true if each element of the vector value \p V is poisoned or equal to</span></div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;<span class="comment">/// every other non-poisoned element. If an index element is specified, either</span></div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;<span class="comment">/// every element of the vector is poisoned or the element at that index is not</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="comment">/// poisoned and equal to every other non-poisoned element.</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="comment">/// This may be more powerful than the related getSplatValue() because it is</span></div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;<span class="comment">/// not limited by finding a scalar source value to a splatted vector.</span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;<span class="comment"></span><span class="keywordtype">bool</span> <a class="code" href="namespacellvm.html#a6339f2ad6701dc229c34ca4305596d3a">isSplatValue</a>(<span class="keyword">const</span> <a class="code" href="namespacellvm_1_1TargetStackID.html#a71392100eb15ba746b1f898986f5d8a5">Value</a> *V, <span class="keywordtype">int</span> <a class="code" href="ELFObjHandler_8cpp.html#aef61945034b9431b804748fc317c5548">Index</a> = -1, <span class="keywordtype">unsigned</span> <a class="code" href="namespacellvm.html#a1eb5609345b906d024fbf9e4bc1adc06afe578efb7ca235af77fb0eef7edcf639">Depth</a> = 0);</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;<span class="comment">/// Replace each shuffle mask index with the scaled sequential indices for an</span></div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;<span class="comment">/// equivalent mask of narrowed elements. Mask elements that are less than 0</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;<span class="comment">/// (sentinel values) are repeated in the output mask.</span></div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;<span class="comment">/// Example with Scale = 4:</span></div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;<span class="comment">///   &lt;4 x i32&gt; &lt;3, 2, 0, -1&gt; --&gt;</span></div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;<span class="comment">///   &lt;16 x i8&gt; &lt;12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1&gt;</span></div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;<span class="comment">/// This is the reverse process of widening shuffle mask elements, but it always</span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="comment">/// succeeds because the indexes can always be multiplied (scaled up) to map to</span></div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;<span class="comment">/// narrower vector elements.</span></div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;<span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="namespacellvm.html#aa91449ed55cd3c525a3438252573527a">narrowShuffleMaskElts</a>(<span class="keywordtype">int</span> Scale, ArrayRef&lt;int&gt; <a class="code" href="namespacellvm_1_1BitmaskEnumDetail.html#ad9273b0ee6c5e0f2367e3136c1503811">Mask</a>,</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;                           SmallVectorImpl&lt;int&gt; &amp;ScaledMask);</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;<span class="comment">/// Try to transform a shuffle mask by replacing elements with the scaled index</span></div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;<span class="comment">/// for an equivalent mask of widened elements. If all mask elements that would</span></div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;<span class="comment">/// map to a wider element of the new mask are the same negative number</span></div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;<span class="comment">/// (sentinel value), that element of the new mask is the same value. If any</span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="comment">/// element in a given slice is negative and some other element in that slice is</span></div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;<span class="comment">/// not the same value, return false (partial matches with sentinel values are</span></div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;<span class="comment">/// not allowed).</span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;<span class="comment">/// Example with Scale = 4:</span></div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;<span class="comment">///   &lt;16 x i8&gt; &lt;12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1&gt; --&gt;</span></div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;<span class="comment">///   &lt;4 x i32&gt; &lt;3, 2, 0, -1&gt;</span></div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;<span class="comment">/// This is the reverse process of narrowing shuffle mask elements if it</span></div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;<span class="comment">/// succeeds. This transform is not always possible because indexes may not</span></div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;<span class="comment">/// divide evenly (scale down) to map to wider vector elements.</span></div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;<span class="comment"></span><span class="keywordtype">bool</span> <a class="code" href="namespacellvm.html#a4373d3025961c2c2eeca56b02d7d009d">widenShuffleMaskElts</a>(<span class="keywordtype">int</span> Scale, ArrayRef&lt;int&gt; <a class="code" href="namespacellvm_1_1BitmaskEnumDetail.html#ad9273b0ee6c5e0f2367e3136c1503811">Mask</a>,</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;                          SmallVectorImpl&lt;int&gt; &amp;ScaledMask);</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;<span class="comment">/// Compute a map of integer instructions to their minimum legal type</span></div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;<span class="comment">/// size.</span></div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;<span class="comment">/// C semantics force sub-int-sized values (e.g. i8, i16) to be promoted to int</span></div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;<span class="comment">/// type (e.g. i32) whenever arithmetic is performed on them.</span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;<span class="comment">/// For targets with native i8 or i16 operations, usually InstCombine can shrink</span></div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;<span class="comment">/// the arithmetic type down again. However InstCombine refuses to create</span></div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;<span class="comment">/// illegal types, so for targets without i8 or i16 registers, the lengthening</span></div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;<span class="comment">/// and shrinking remains.</span></div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="comment">/// Most SIMD ISAs (e.g. NEON) however support vectors of i8 or i16 even when</span></div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="comment">/// their scalar equivalents do not, so during vectorization it is important to</span></div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="comment">/// remove these lengthens and truncates when deciding the profitability of</span></div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="comment">/// vectorization.</span></div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;<span class="comment">/// This function analyzes the given range of instructions and determines the</span></div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;<span class="comment">/// minimum type size each can be converted to. It attempts to remove or</span></div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;<span class="comment">/// minimize type size changes across each def-use chain, so for example in the</span></div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;<span class="comment">/// following code:</span></div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;<span class="comment">///   %1 = load i8, i8*</span></div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;<span class="comment">///   %2 = add i8 %1, 2</span></div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;<span class="comment">///   %3 = load i16, i16*</span></div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;<span class="comment">///   %4 = zext i8 %2 to i32</span></div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;<span class="comment">///   %5 = zext i16 %3 to i32</span></div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;<span class="comment">///   %6 = add i32 %4, %5</span></div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;<span class="comment">///   %7 = trunc i32 %6 to i16</span></div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;<span class="comment">/// Instruction %6 must be done at least in i16, so computeMinimumValueSizes</span></div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;<span class="comment">/// will return: {%1: 16, %2: 16, %3: 16, %4: 16, %5: 16, %6: 16, %7: 16}.</span></div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;<span class="comment">/// If the optional TargetTransformInfo is provided, this function tries harder</span></div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;<span class="comment">/// to do less work by only looking at illegal types.</span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;<span class="comment"></span>MapVector&lt;Instruction*, uint64_t&gt;</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;<a class="code" href="namespacellvm.html#af7b6ae12af3578f7a20ccc11a4458f9f">computeMinimumValueSizes</a>(ArrayRef&lt;BasicBlock*&gt; Blocks,</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;                         DemandedBits &amp;DB,</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;                         <span class="keyword">const</span> TargetTransformInfo *<a class="code" href="namespacellvm.html#aa0d69e81725c10fa5407f0bf34462068">TTI</a>=<span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;<span class="comment">/// Compute the union of two access-group lists.</span></div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;<span class="comment">/// If the list contains just one access group, it is returned directly. If the</span></div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;<span class="comment">/// list is empty, returns nullptr.</span></div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;<span class="comment"></span>MDNode *<a class="code" href="namespacellvm.html#ab307a287351370b59786ef96c73738cb">uniteAccessGroups</a>(MDNode *AccGroups1, MDNode *AccGroups2);</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;<span class="comment">/// Compute the access-group list of access groups that @p Inst1 and @p Inst2</span></div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;<span class="comment">/// are both in. If either instruction does not access memory at all, it is</span></div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;<span class="comment">/// considered to be in every list.</span></div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;<span class="comment">/// If the list contains just one access group, it is returned directly. If the</span></div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;<span class="comment">/// list is empty, returns nullptr.</span></div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;<span class="comment"></span>MDNode *<a class="code" href="namespacellvm.html#a51d22a1ed809d7cb1c1eb46c820c8226">intersectAccessGroups</a>(<span class="keyword">const</span> Instruction *Inst1,</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;                              <span class="keyword">const</span> Instruction *Inst2);</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="comment">/// Specifically, let Kinds = [MD_tbaa, MD_alias_scope, MD_noalias, MD_fpmath,</span></div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;<span class="comment">/// MD_nontemporal, MD_access_group].</span></div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;<span class="comment">/// For K in Kinds, we get the MDNode for K from each of the</span></div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;<span class="comment">/// elements of VL, compute their &quot;intersection&quot; (i.e., the most generic</span></div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;<span class="comment">/// metadata value that covers all of the individual values), and set I&#39;s</span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;<span class="comment">/// metadata for M equal to the intersection value.</span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;<span class="comment">/// This function always sets a (possibly null) value for each K in Kinds.</span></div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;<span class="comment"></span>Instruction *<a class="code" href="namespacellvm.html#a48a6deb3e714d54e75caadcf84b0ca76">propagateMetadata</a>(Instruction *<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, ArrayRef&lt;Value *&gt; VL);</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;<span class="comment">/// Create a mask that filters the members of an interleave group where there</span></div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;<span class="comment">/// are gaps.</span></div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;<span class="comment">/// For example, the mask for \p Group with interleave-factor 3</span></div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;<span class="comment">/// and \p VF 4, that has only its first member present is:</span></div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;<span class="comment">///   &lt;1,0,0,1,0,0,1,0,0,1,0,0&gt;</span></div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;<span class="comment">/// Note: The result is a mask of 0&#39;s and 1&#39;s, as opposed to the other</span></div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;<span class="comment">/// create[*]Mask() utilities which create a shuffle mask (mask that</span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;<span class="comment">/// consists of indices).</span></div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;<span class="comment"></span>Constant *<a class="code" href="namespacellvm.html#a673cf7e3d4e84d3e3dfa9dc000499cba">createBitMaskForGaps</a>(IRBuilderBase &amp;<a class="code" href="AssumeBundleBuilder_8cpp.html#afb136e0532bcaed86521b462e6538d62">Builder</a>, <span class="keywordtype">unsigned</span> VF,</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;                               <span class="keyword">const</span> InterleaveGroup&lt;Instruction&gt; &amp;Group);</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;<span class="comment">/// Create a mask with replicated elements.</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;<span class="comment">/// This function creates a shuffle mask for replicating each of the \p VF</span></div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;<span class="comment">/// elements in a vector \p ReplicationFactor times. It can be used to</span></div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;<span class="comment">/// transform a mask of \p VF elements into a mask of</span></div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;<span class="comment">/// \p VF * \p ReplicationFactor elements used by a predicated</span></div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;<span class="comment">/// interleaved-group of loads/stores whose Interleaved-factor ==</span></div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;<span class="comment">/// \p ReplicationFactor.</span></div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;<span class="comment">/// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:</span></div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;<span class="comment">///   &lt;0,0,0,1,1,1,2,2,2,3,3,3&gt;</span></div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;<span class="comment"></span><a class="code" href="classllvm_1_1SmallVector.html">llvm::SmallVector&lt;int, 16&gt;</a> <a class="code" href="namespacellvm.html#a7504dd988bee776d391c05231515297d">createReplicatedMask</a>(<span class="keywordtype">unsigned</span> ReplicationFactor,</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;                                                <span class="keywordtype">unsigned</span> VF);</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;<span class="comment">/// Create an interleave shuffle mask.</span></div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;<span class="comment">/// This function creates a shuffle mask for interleaving \p NumVecs vectors of</span></div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;<span class="comment">/// vectorization factor \p VF into a single wide vector. The mask is of the</span></div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;<span class="comment">/// form:</span></div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;<span class="comment">///   &lt;0, VF, VF * 2, ..., VF * (NumVecs - 1), 1, VF + 1, VF * 2 + 1, ...&gt;</span></div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;<span class="comment">/// For example, the mask for VF = 4 and NumVecs = 2 is:</span></div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;<span class="comment">///   &lt;0, 4, 1, 5, 2, 6, 3, 7&gt;.</span></div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;<span class="comment"></span><a class="code" href="classllvm_1_1SmallVector.html">llvm::SmallVector&lt;int, 16&gt;</a> <a class="code" href="namespacellvm.html#aab4ac3afe77847f88a5bec4ef29e68fa">createInterleaveMask</a>(<span class="keywordtype">unsigned</span> VF, <span class="keywordtype">unsigned</span> NumVecs);</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;<span class="comment">/// Create a stride shuffle mask.</span></div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;<span class="comment">/// This function creates a shuffle mask whose elements begin at \p Start and</span></div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;<span class="comment">/// are incremented by \p Stride. The mask can be used to deinterleave an</span></div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;<span class="comment">/// interleaved vector into separate vectors of vectorization factor \p VF. The</span></div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;<span class="comment">/// mask is of the form:</span></div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;<span class="comment">///   &lt;Start, Start + Stride, ..., Start + Stride * (VF - 1)&gt;</span></div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;<span class="comment">/// For example, the mask for Start = 0, Stride = 2, and VF = 4 is:</span></div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;<span class="comment">///   &lt;0, 2, 4, 6&gt;</span></div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;<span class="comment"></span><a class="code" href="classllvm_1_1SmallVector.html">llvm::SmallVector&lt;int, 16&gt;</a> <a class="code" href="namespacellvm.html#a689f785bfa4f3650dc44d519df0406fd">createStrideMask</a>(<span class="keywordtype">unsigned</span> Start, <span class="keywordtype">unsigned</span> Stride,</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;                                            <span class="keywordtype">unsigned</span> VF);</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;<span class="comment">/// Create a sequential shuffle mask.</span></div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;<span class="comment">/// This function creates shuffle mask whose elements are sequential and begin</span></div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;<span class="comment">/// at \p Start.  The mask contains \p NumInts integers and is padded with \p</span></div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;<span class="comment">/// NumUndefs undef values. The mask is of the form:</span></div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;<span class="comment">///   &lt;Start, Start + 1, ... Start + NumInts - 1, undef_1, ... undef_NumUndefs&gt;</span></div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;<span class="comment">/// For example, the mask for Start = 0, NumInsts = 4, and NumUndefs = 4 is:</span></div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;<span class="comment">///   &lt;0, 1, 2, 3, undef, undef, undef, undef&gt;</span></div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;<span class="comment"></span><a class="code" href="classllvm_1_1SmallVector.html">llvm::SmallVector&lt;int, 16&gt;</a></div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;<a class="code" href="namespacellvm.html#af00a6f39da9d94ec387a366ade60aea5">createSequentialMask</a>(<span class="keywordtype">unsigned</span> Start, <span class="keywordtype">unsigned</span> NumInts, <span class="keywordtype">unsigned</span> NumUndefs);</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;<span class="comment">/// Concatenate a list of vectors.</span></div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;<span class="comment">/// This function generates code that concatenate the vectors in \p Vecs into a</span></div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;<span class="comment">/// single large vector. The number of vectors should be greater than one, and</span></div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;<span class="comment">/// their element types should be the same. The number of elements in the</span></div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;<span class="comment">/// vectors should also be the same; however, if the last vector has fewer</span></div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;<span class="comment">/// elements, it will be padded with undefs.</span></div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;<span class="comment"></span><a class="code" href="namespacellvm_1_1TargetStackID.html#a71392100eb15ba746b1f898986f5d8a5">Value</a> *<a class="code" href="namespacellvm.html#a4288169d91ab0f0f01405115fd2931a7">concatenateVectors</a>(IRBuilderBase &amp;<a class="code" href="AssumeBundleBuilder_8cpp.html#afb136e0532bcaed86521b462e6538d62">Builder</a>, ArrayRef&lt;Value *&gt; Vecs);</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;<span class="comment">/// Given a mask vector of i1, Return true if all of the elements of this</span></div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;<span class="comment">/// predicate mask are known to be false or undef.  That is, return true if all</span></div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;<span class="comment">/// lanes can be assumed inactive.</span></div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;<span class="comment"></span><span class="keywordtype">bool</span> <a class="code" href="namespacellvm.html#ac43e0b6cbbe1e0d8988e9c5482573a92">maskIsAllZeroOrUndef</a>(<a class="code" href="namespacellvm_1_1TargetStackID.html#a71392100eb15ba746b1f898986f5d8a5">Value</a> *<a class="code" href="namespacellvm_1_1BitmaskEnumDetail.html#ad9273b0ee6c5e0f2367e3136c1503811">Mask</a>);</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;<span class="comment">/// Given a mask vector of i1, Return true if all of the elements of this</span></div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;<span class="comment">/// predicate mask are known to be true or undef.  That is, return true if all</span></div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;<span class="comment">/// lanes can be assumed active.</span></div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;<span class="comment"></span><span class="keywordtype">bool</span> <a class="code" href="namespacellvm.html#a961f14c05fb26ae34f8dabdd2013b7d6">maskIsAllOneOrUndef</a>(<a class="code" href="namespacellvm_1_1TargetStackID.html#a71392100eb15ba746b1f898986f5d8a5">Value</a> *<a class="code" href="namespacellvm_1_1BitmaskEnumDetail.html#ad9273b0ee6c5e0f2367e3136c1503811">Mask</a>);</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;<span class="comment">/// Given a mask vector of the form &lt;Y x i1&gt;, return an APInt (of bitwidth Y)</span></div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;<span class="comment">/// for each lane which may be active.</span></div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;<span class="comment"></span>APInt <a class="code" href="namespacellvm.html#a1a0a402f51b5d937bbd3accc7bb354ab">possiblyDemandedEltsInMask</a>(<a class="code" href="namespacellvm_1_1TargetStackID.html#a71392100eb15ba746b1f898986f5d8a5">Value</a> *<a class="code" href="namespacellvm_1_1BitmaskEnumDetail.html#ad9273b0ee6c5e0f2367e3136c1503811">Mask</a>);</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="comment">/// The group of interleaved loads/stores sharing the same stride and</span></div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="comment">/// close to each other.</span></div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;<span class="comment">/// Each member in this group has an index starting from 0, and the largest</span></div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;<span class="comment">/// index should be less than interleaved factor, which is equal to the absolute</span></div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;<span class="comment">/// value of the access&#39;s stride.</span></div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;<span class="comment">/// E.g. An interleaved load group of factor 4:</span></div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;<span class="comment">///        for (unsigned i = 0; i &lt; 1024; i+=4) {</span></div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;<span class="comment">///          a = A[i];                           // Member of index 0</span></div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;<span class="comment">///          b = A[i+1];                         // Member of index 1</span></div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;<span class="comment">///          d = A[i+3];                         // Member of index 3</span></div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;<span class="comment">///          ...</span></div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;<span class="comment">///        }</span></div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;<span class="comment">///      An interleaved store group of factor 4:</span></div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;<span class="comment">///        for (unsigned i = 0; i &lt; 1024; i+=4) {</span></div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;<span class="comment">///          ...</span></div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;<span class="comment">///          A[i]   = a;                         // Member of index 0</span></div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;<span class="comment">///          A[i+1] = b;                         // Member of index 1</span></div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;<span class="comment">///          A[i+2] = c;                         // Member of index 2</span></div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;<span class="comment">///          A[i+3] = d;                         // Member of index 3</span></div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<span class="comment">///        }</span></div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;<span class="comment">/// Note: the interleaved load group could have gaps (missing members), but</span></div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;<span class="comment">/// the interleaved store group doesn&#39;t allow gaps.</span></div>
<div class="line"><a name="l00585"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleaveGroup.html">  585</a></span>&#160;<span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InstTy&gt; <span class="keyword">class </span><a class="code" href="classllvm_1_1InterleaveGroup.html">InterleaveGroup</a> {</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;<span class="keyword">public</span>:</div>
<div class="line"><a name="l00587"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleaveGroup.html#a53b02fefd57973cff5c9bc7a7badde56">  587</a></span>&#160;  <a class="code" href="classllvm_1_1InterleaveGroup.html#a53b02fefd57973cff5c9bc7a7badde56">InterleaveGroup</a>(<a class="code" href="classuint32__t.html">uint32_t</a> Factor, <span class="keywordtype">bool</span> Reverse, <a class="code" href="structllvm_1_1Align.html">Align</a> Alignment)</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;      : Factor(Factor), Reverse(Reverse), Alignment(Alignment),</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;        InsertPos(nullptr) {}</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160; </div>
<div class="line"><a name="l00591"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleaveGroup.html#aa39b702ab803808098afedd96623cd92">  591</a></span>&#160;  <a class="code" href="classllvm_1_1InterleaveGroup.html#aa39b702ab803808098afedd96623cd92">InterleaveGroup</a>(InstTy *Instr, int32_t Stride, <a class="code" href="structllvm_1_1Align.html">Align</a> Alignment)</div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;      : Alignment(Alignment), InsertPos(Instr) {</div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;    Factor = <a class="code" href="namespacellvm.html#a2816e84a08c108d18bc4665bc1817e01">std::abs</a>(Stride);</div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;    <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(Factor &gt; 1 &amp;&amp; <span class="stringliteral">&quot;Invalid interleave factor&quot;</span>);</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160; </div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    Reverse = Stride &lt; 0;</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    Members[0] = Instr;</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;  }</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160; </div>
<div class="line"><a name="l00600"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleaveGroup.html#a776b9e4e25dda6aff28a94e69a7533e6">  600</a></span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1InterleaveGroup.html#a776b9e4e25dda6aff28a94e69a7533e6">isReverse</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> Reverse; }</div>
<div class="line"><a name="l00601"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleaveGroup.html#a46f3b431a3121fdf53608a283bf4efec">  601</a></span>&#160;  <a class="code" href="classuint32__t.html">uint32_t</a> <a class="code" href="classllvm_1_1InterleaveGroup.html#a46f3b431a3121fdf53608a283bf4efec">getFactor</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> Factor; }</div>
<div class="line"><a name="l00602"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleaveGroup.html#aa311eadfce08b1fa5cf55c6c2008bb47">  602</a></span>&#160;  <a class="code" href="structllvm_1_1Align.html">Align</a> <a class="code" href="classllvm_1_1InterleaveGroup.html#aa311eadfce08b1fa5cf55c6c2008bb47">getAlign</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> Alignment; }</div>
<div class="line"><a name="l00603"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleaveGroup.html#af81c826ee51addc3321e4ef1c1934696">  603</a></span>&#160;  <a class="code" href="classuint32__t.html">uint32_t</a> <a class="code" href="classllvm_1_1InterleaveGroup.html#af81c826ee51addc3321e4ef1c1934696">getNumMembers</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> Members.<a class="code" href="classllvm_1_1DenseMapBase.html#a3d95cc2d359b8d9ed5bd9504b44930b5">size</a>(); }</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="comment">  /// Try to insert a new member \p Instr with index \p Index and</span></div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;<span class="comment">  /// alignment \p NewAlign. The index is related to the leader and it could be</span></div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;<span class="comment">  /// negative if it is the new leader.</span></div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;<span class="comment">  ///</span></div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;<span class="comment">  /// \returns false if the instruction doesn&#39;t belong to the group.</span></div>
<div class="line"><a name="l00610"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleaveGroup.html#ad2398638cf12a8318566a3fc6cc0e771">  610</a></span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1InterleaveGroup.html#ad2398638cf12a8318566a3fc6cc0e771">insertMember</a>(InstTy *Instr, int32_t <a class="code" href="ELFObjHandler_8cpp.html#aef61945034b9431b804748fc317c5548">Index</a>, <a class="code" href="structllvm_1_1Align.html">Align</a> NewAlign) {</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;    <span class="comment">// Make sure the key fits in an int32_t.</span></div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;    <a class="code" href="classllvm_1_1Optional.html">Optional&lt;int32_t&gt;</a> MaybeKey = <a class="code" href="namespacellvm.html#a277fb9dbf4fa0638e214ac4777544e83">checkedAdd</a>(<a class="code" href="ELFObjHandler_8cpp.html#aef61945034b9431b804748fc317c5548">Index</a>, SmallestKey);</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;    <span class="keywordflow">if</span> (!MaybeKey)</div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;    int32_t <a class="code" href="namespacellvm_1_1AMDGPU_1_1PALMD.html#af892c75285b0f64d58ca76cb73059adf">Key</a> = *MaybeKey;</div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160; </div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;    <span class="comment">// Skip if the key is used for either the tombstone or empty special values.</span></div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="structllvm_1_1DenseMapInfo.html">DenseMapInfo&lt;int32_t&gt;::getTombstoneKey</a>() == <a class="code" href="namespacellvm_1_1AMDGPU_1_1PALMD.html#af892c75285b0f64d58ca76cb73059adf">Key</a> ||</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;        <a class="code" href="structllvm_1_1DenseMapInfo.html">DenseMapInfo&lt;int32_t&gt;::getEmptyKey</a>() == <a class="code" href="namespacellvm_1_1AMDGPU_1_1PALMD.html#af892c75285b0f64d58ca76cb73059adf">Key</a>)</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160; </div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;    <span class="comment">// Skip if there is already a member with the same index.</span></div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;    <span class="keywordflow">if</span> (Members.<a class="code" href="classllvm_1_1DenseMapBase.html#a0c047f127ed4380a6f383d70bec4eb94">find</a>(<a class="code" href="namespacellvm_1_1AMDGPU_1_1PALMD.html#af892c75285b0f64d58ca76cb73059adf">Key</a>) != Members.<a class="code" href="classllvm_1_1DenseMapBase.html#a65520b9c67759099e313d0f4e7b5ff9e">end</a>())</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160; </div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacellvm_1_1AMDGPU_1_1PALMD.html#af892c75285b0f64d58ca76cb73059adf">Key</a> &gt; LargestKey) {</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;      <span class="comment">// The largest index is always less than the interleave factor.</span></div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="ELFObjHandler_8cpp.html#aef61945034b9431b804748fc317c5548">Index</a> &gt;= <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(Factor))</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160; </div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;      LargestKey = <a class="code" href="namespacellvm_1_1AMDGPU_1_1PALMD.html#af892c75285b0f64d58ca76cb73059adf">Key</a>;</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacellvm_1_1AMDGPU_1_1PALMD.html#af892c75285b0f64d58ca76cb73059adf">Key</a> &lt; SmallestKey) {</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160; </div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;      <span class="comment">// Make sure the largest index fits in an int32_t.</span></div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;      <a class="code" href="classllvm_1_1Optional.html">Optional&lt;int32_t&gt;</a> MaybeLargestIndex = <a class="code" href="namespacellvm.html#a3d465d135c62843160741eeddf360da9">checkedSub</a>(LargestKey, <a class="code" href="namespacellvm_1_1AMDGPU_1_1PALMD.html#af892c75285b0f64d58ca76cb73059adf">Key</a>);</div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;      <span class="keywordflow">if</span> (!MaybeLargestIndex)</div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160; </div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;      <span class="comment">// The largest index is always less than the interleave factor.</span></div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;      <span class="keywordflow">if</span> (*MaybeLargestIndex &gt;= <span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(Factor))</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160; </div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;      SmallestKey = <a class="code" href="namespacellvm_1_1AMDGPU_1_1PALMD.html#af892c75285b0f64d58ca76cb73059adf">Key</a>;</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;    }</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160; </div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;    <span class="comment">// It&#39;s always safe to select the minimum alignment.</span></div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;    Alignment = <a class="code" href="namespacellvm.html#a57f2ca0e57f4f7b13f56f9aa16af3e0d">std::min</a>(Alignment, NewAlign);</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;    Members[<a class="code" href="namespacellvm_1_1AMDGPU_1_1PALMD.html#af892c75285b0f64d58ca76cb73059adf">Key</a>] = Instr;</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;  }</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;<span class="comment">  /// Get the member with the given index \p Index</span></div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;<span class="comment">  ///</span></div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;<span class="comment">  /// \returns nullptr if contains no such member.</span></div>
<div class="line"><a name="l00655"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleaveGroup.html#ab945330dc19d757dfe310145636b370c">  655</a></span>&#160;<span class="comment"></span>  InstTy *<a class="code" href="classllvm_1_1InterleaveGroup.html#ab945330dc19d757dfe310145636b370c">getMember</a>(<a class="code" href="classuint32__t.html">uint32_t</a> <a class="code" href="ELFObjHandler_8cpp.html#aef61945034b9431b804748fc317c5548">Index</a>)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;    int32_t <a class="code" href="namespacellvm_1_1AMDGPU_1_1PALMD.html#af892c75285b0f64d58ca76cb73059adf">Key</a> = SmallestKey + <a class="code" href="ELFObjHandler_8cpp.html#aef61945034b9431b804748fc317c5548">Index</a>;</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;    <span class="keywordflow">return</span> Members.<a class="code" href="classllvm_1_1DenseMapBase.html#a0b2ca98dc28c61793ff5c90d23e5f14e">lookup</a>(<a class="code" href="namespacellvm_1_1AMDGPU_1_1PALMD.html#af892c75285b0f64d58ca76cb73059adf">Key</a>);</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;  }</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;<span class="comment">  /// Get the index for the given member. Unlike the key in the member</span></div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;<span class="comment">  /// map, the index starts from 0.</span></div>
<div class="line"><a name="l00662"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleaveGroup.html#a5bb08a7480808cec4d5b9e1d0a3012c6">  662</a></span>&#160;<span class="comment"></span>  <a class="code" href="classuint32__t.html">uint32_t</a> <a class="code" href="classllvm_1_1InterleaveGroup.html#a5bb08a7480808cec4d5b9e1d0a3012c6">getIndex</a>(<span class="keyword">const</span> InstTy *Instr)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> : Members) {</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>.second == Instr)</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>.first - SmallestKey;</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;    }</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160; </div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;    <a class="code" href="llvm_2Support_2ErrorHandling_8h.html#ace243f5c25697a1107cce46626b3dc94">llvm_unreachable</a>(<span class="stringliteral">&quot;InterleaveGroup contains no such member&quot;</span>);</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;  }</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160; </div>
<div class="line"><a name="l00671"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleaveGroup.html#aac206f570f599e8832d28a15bddb12d5">  671</a></span>&#160;  InstTy *<a class="code" href="classllvm_1_1InterleaveGroup.html#aac206f570f599e8832d28a15bddb12d5">getInsertPos</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> InsertPos; }</div>
<div class="line"><a name="l00672"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleaveGroup.html#a722a0e30a844c1f562b38ca7e06d6213">  672</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classllvm_1_1InterleaveGroup.html#a722a0e30a844c1f562b38ca7e06d6213">setInsertPos</a>(InstTy *Inst) { InsertPos = Inst; }</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;<span class="comment">  /// Add metadata (e.g. alias info) from the instructions in this group to \p</span></div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;<span class="comment">  /// NewInst.</span></div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;<span class="comment">  ///</span></div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;<span class="comment">  /// FIXME: this function currently does not add noalias metadata a&#39;la</span></div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;<span class="comment">  /// addNewMedata.  To do that we need to compute the intersection of the</span></div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;<span class="comment">  /// noalias info from all members.</span></div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="classllvm_1_1InterleaveGroup.html#a9c748347f137d9e3d6c51833e6882272">addMetadata</a>(InstTy *NewInst) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;<span class="comment">  /// Returns true if this Group requires a scalar iteration to handle gaps.</span></div>
<div class="line"><a name="l00683"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleaveGroup.html#a3c0ed6567fafd374da72087409959b75">  683</a></span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1InterleaveGroup.html#a3c0ed6567fafd374da72087409959b75">requiresScalarEpilogue</a>()<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;    <span class="comment">// If the last member of the Group exists, then a scalar epilog is not</span></div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;    <span class="comment">// needed for this group.</span></div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1InterleaveGroup.html#ab945330dc19d757dfe310145636b370c">getMember</a>(<a class="code" href="classllvm_1_1InterleaveGroup.html#a46f3b431a3121fdf53608a283bf4efec">getFactor</a>() - 1))</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160; </div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;    <span class="comment">// We have a group with gaps. It therefore cannot be a group of stores,</span></div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;    <span class="comment">// and it can&#39;t be a reversed access, because such groups get invalidated.</span></div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;    <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(!<a class="code" href="classllvm_1_1InterleaveGroup.html#ab945330dc19d757dfe310145636b370c">getMember</a>(0)-&gt;mayWriteToMemory() &amp;&amp;</div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;           <span class="stringliteral">&quot;Group should have been invalidated&quot;</span>);</div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;    <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(!<a class="code" href="classllvm_1_1InterleaveGroup.html#a776b9e4e25dda6aff28a94e69a7533e6">isReverse</a>() &amp;&amp; <span class="stringliteral">&quot;Group should have been invalidated&quot;</span>);</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160; </div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;    <span class="comment">// This is a group of loads, with gaps, and without a last-member</span></div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;  }</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160; </div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;<span class="keyword">private</span>:</div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;  <a class="code" href="classuint32__t.html">uint32_t</a> Factor; <span class="comment">// Interleave Factor.</span></div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;  <span class="keywordtype">bool</span> Reverse;</div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;  <a class="code" href="structllvm_1_1Align.html">Align</a> Alignment;</div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;  <a class="code" href="classllvm_1_1DenseMap.html">DenseMap&lt;int32_t, InstTy *&gt;</a> Members;</div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;  int32_t SmallestKey = 0;</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;  int32_t LargestKey = 0;</div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160; </div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;  <span class="comment">// To avoid breaking dependences, vectorized instructions of an interleave</span></div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;  <span class="comment">// group should be inserted at either the first load or the last store in</span></div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;  <span class="comment">// program order.</span></div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;  <span class="comment">// E.g. %even = load i32             // Insert Position</span></div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;  <span class="comment">//      %add = add i32 %even         // Use of %even</span></div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;  <span class="comment">//      %odd = load i32</span></div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;  <span class="comment">//      store i32 %even</span></div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;  <span class="comment">//      %odd = add i32               // Def of %odd</span></div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;  <span class="comment">//      store i32 %odd               // Insert Position</span></div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;  InstTy *InsertPos;</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;};</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;<span class="comment">/// Drive the analysis of interleaved memory accesses in the loop.</span></div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;<span class="comment">/// Use this class to analyze interleaved accesses only when we can vectorize</span></div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;<span class="comment">/// a loop. Otherwise it&#39;s meaningless to do analysis as the vectorization</span></div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;<span class="comment">/// on interleaved accesses is unsafe.</span></div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;<span class="comment">/// The analysis collects interleave groups and records the relationships</span></div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;<span class="comment">/// between the member and the group in a map.</span></div>
<div class="line"><a name="l00729"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleavedAccessInfo.html">  729</a></span>&#160;<span class="comment"></span><span class="keyword">class </span><a class="code" href="classllvm_1_1InterleavedAccessInfo.html">InterleavedAccessInfo</a> {</div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;<span class="keyword">public</span>:</div>
<div class="line"><a name="l00731"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleavedAccessInfo.html#afdb6529eb70fb9aed0036ebc1a864c49">  731</a></span>&#160;  <a class="code" href="classllvm_1_1InterleavedAccessInfo.html#afdb6529eb70fb9aed0036ebc1a864c49">InterleavedAccessInfo</a>(<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html">PredicatedScalarEvolution</a> &amp;PSE, <a class="code" href="classllvm_1_1Loop.html">Loop</a> *L,</div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;                        <a class="code" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT, <a class="code" href="classllvm_1_1LoopInfo.html">LoopInfo</a> *LI,</div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;                        <span class="keyword">const</span> <a class="code" href="classllvm_1_1LoopAccessInfo.html">LoopAccessInfo</a> *LAI)</div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;      : PSE(PSE), TheLoop(L), DT(DT), LI(LI), LAI(LAI) {}</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160; </div>
<div class="line"><a name="l00736"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleavedAccessInfo.html#afbe177a202a10b44c23c97acb07a1992">  736</a></span>&#160;  <a class="code" href="classllvm_1_1InterleavedAccessInfo.html#afbe177a202a10b44c23c97acb07a1992">~InterleavedAccessInfo</a>() { <a class="code" href="classllvm_1_1InterleavedAccessInfo.html#a9d9b6620a692f452f5080cb0c20e41e3">invalidateGroups</a>(); }</div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;<span class="comment">  /// Analyze the interleaved accesses and collect them in interleave</span></div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;<span class="comment">  /// groups. Substitute symbolic strides using \p Strides.</span></div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;<span class="comment">  /// Consider also predicated loads/stores in the analysis if</span></div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;<span class="comment">  /// \p EnableMaskedInterleavedGroup is true.</span></div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="classllvm_1_1InterleavedAccessInfo.html#af587d7218fa15a456103c3d2125a1fc8">analyzeInterleaving</a>(<span class="keywordtype">bool</span> EnableMaskedInterleavedGroup);</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;<span class="comment">  /// Invalidate groups, e.g., in case all blocks in loop will be predicated</span></div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;<span class="comment">  /// contrary to original assumption. Although we currently prevent group</span></div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;<span class="comment">  /// formation for predicated accesses, we may be able to relax this limitation</span></div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;<span class="comment">  /// in the future once we handle more complicated blocks. Returns true if any</span></div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;<span class="comment">  /// groups were invalidated.</span></div>
<div class="line"><a name="l00749"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleavedAccessInfo.html#a9d9b6620a692f452f5080cb0c20e41e3">  749</a></span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1InterleavedAccessInfo.html#a9d9b6620a692f452f5080cb0c20e41e3">invalidateGroups</a>() {</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;    <span class="keywordflow">if</span> (InterleaveGroups.empty()) {</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;      <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;          !RequiresScalarEpilogue &amp;&amp;</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;          <span class="stringliteral">&quot;RequiresScalarEpilog should not be set without interleave groups&quot;</span>);</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;    }</div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160; </div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;    InterleaveGroupMap.clear();</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> *Ptr : InterleaveGroups)</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;      <span class="keyword">delete</span> Ptr;</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;    InterleaveGroups.clear();</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;    RequiresScalarEpilogue = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;  }</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;<span class="comment">  /// Check if \p Instr belongs to any interleave group.</span></div>
<div class="line"><a name="l00766"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleavedAccessInfo.html#a7697f9f41ff04e918857f5af7c36fc2a">  766</a></span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1InterleavedAccessInfo.html#a7697f9f41ff04e918857f5af7c36fc2a">isInterleaved</a>(<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *Instr)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;    <span class="keywordflow">return</span> InterleaveGroupMap.find(Instr) != InterleaveGroupMap.end();</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;  }</div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;<span class="comment">  /// Get the interleave group that \p Instr belongs to.</span></div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;<span class="comment">  ///</span></div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;<span class="comment">  /// \returns nullptr if doesn&#39;t have such group.</span></div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1InterleaveGroup.html">InterleaveGroup&lt;Instruction&gt;</a> *</div>
<div class="line"><a name="l00774"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleavedAccessInfo.html#aff4d67798e0101bd9f69dd6de204dcd1">  774</a></span>&#160;  <a class="code" href="classllvm_1_1InterleavedAccessInfo.html#aff4d67798e0101bd9f69dd6de204dcd1">getInterleaveGroup</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *Instr)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;    <span class="keywordflow">return</span> InterleaveGroupMap.lookup(Instr);</div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;  }</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160; </div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;  <a class="code" href="classllvm_1_1iterator__range.html">iterator_range&lt;SmallPtrSetIterator&lt;llvm::InterleaveGroup&lt;Instruction&gt;</a> *&gt;&gt;</div>
<div class="line"><a name="l00779"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleavedAccessInfo.html#a3a6e7f9f2e6125cd856a51aefc741091">  779</a></span>&#160;  <a class="code" href="classllvm_1_1InterleavedAccessInfo.html#a3a6e7f9f2e6125cd856a51aefc741091">getInterleaveGroups</a>() {</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacellvm.html#ad1a91b49e0c092818a0b82f6cc130a1b">make_range</a>(InterleaveGroups.begin(), InterleaveGroups.end());</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;  }</div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;<span class="comment">  /// Returns true if an interleaved group that may access memory</span></div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;<span class="comment">  /// out-of-bounds requires a scalar epilogue iteration for correctness.</span></div>
<div class="line"><a name="l00785"></a><span class="lineno"><a class="line" href="classllvm_1_1InterleavedAccessInfo.html#a34ed64ff27fabc002da4047589142b02">  785</a></span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1InterleavedAccessInfo.html#a34ed64ff27fabc002da4047589142b02">requiresScalarEpilogue</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> RequiresScalarEpilogue; }</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;<span class="comment">  /// Invalidate groups that require a scalar epilogue (due to gaps). This can</span></div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;<span class="comment">  /// happen when optimizing for size forbids a scalar epilogue, and the gap</span></div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;<span class="comment">  /// cannot be filtered by masking the load/store.</span></div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="classllvm_1_1InterleavedAccessInfo.html#afad01409b57e77467d7cafa03ffe3d3f">invalidateGroupsRequiringScalarEpilogue</a>();</div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160; </div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;<span class="keyword">private</span>:<span class="comment"></span></div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;<span class="comment">  /// A wrapper around ScalarEvolution, used to add runtime SCEV checks.</span></div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;<span class="comment">  /// Simplifies SCEV expressions in the context of existing SCEV assumptions.</span></div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;<span class="comment">  /// The interleaved access analysis can also add new predicates (for example</span></div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;<span class="comment">  /// by versioning strides of pointers).</span></div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1PredicatedScalarEvolution.html">PredicatedScalarEvolution</a> &amp;PSE;</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160; </div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;  <a class="code" href="classllvm_1_1Loop.html">Loop</a> *TheLoop;</div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;  <a class="code" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT;</div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;  <a class="code" href="classllvm_1_1LoopInfo.html">LoopInfo</a> *LI;</div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1LoopAccessInfo.html">LoopAccessInfo</a> *LAI;</div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;<span class="comment">  /// True if the loop may contain non-reversed interleaved groups with</span></div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;<span class="comment">  /// out-of-bounds accesses. We ensure we don&#39;t speculatively access memory</span></div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;<span class="comment">  /// out-of-bounds by executing at least one scalar epilogue iteration.</span></div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> RequiresScalarEpilogue = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;<span class="comment">  /// Holds the relationships between the members and the interleave group.</span></div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1DenseMap.html">DenseMap&lt;Instruction *, InterleaveGroup&lt;Instruction&gt;</a> *&gt; InterleaveGroupMap;</div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160; </div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;  <a class="code" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet&lt;InterleaveGroup&lt;Instruction&gt;</a> *, 4&gt; InterleaveGroups;</div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;<span class="comment">  /// Holds dependences among the memory accesses in the loop. It maps a source</span></div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;<span class="comment">  /// access to a set of dependent sink accesses.</span></div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1DenseMap.html">DenseMap&lt;Instruction *, SmallPtrSet&lt;Instruction *, 2&gt;</a>&gt; Dependences;</div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;<span class="comment">  /// The descriptor for a strided memory access.</span></div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;<span class="comment"></span>  <span class="keyword">struct </span>StrideDescriptor {</div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;    StrideDescriptor() = <span class="keywordflow">default</span>;</div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;    StrideDescriptor(int64_t Stride, <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *Scev, uint64_t <a class="code" href="namespacellvm_1_1Check.html#a067ee17412e800f03802fa9517685732a3450a9712780ac26b071f9da4288a396">Size</a>,</div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;                     <a class="code" href="structllvm_1_1Align.html">Align</a> Alignment)</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;        : Stride(Stride), Scev(Scev), <a class="code" href="namespacellvm_1_1Check.html#a067ee17412e800f03802fa9517685732a3450a9712780ac26b071f9da4288a396">Size</a>(<a class="code" href="namespacellvm_1_1Check.html#a067ee17412e800f03802fa9517685732a3450a9712780ac26b071f9da4288a396">Size</a>), Alignment(Alignment) {}</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160; </div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;    <span class="comment">// The access&#39;s stride. It is negative for a reverse access.</span></div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;    int64_t Stride = 0;</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160; </div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;    <span class="comment">// The scalar expression of this access.</span></div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;    <span class="keyword">const</span> SCEV *Scev = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160; </div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;    <span class="comment">// The size of the memory object.</span></div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;    uint64_t <a class="code" href="namespacellvm_1_1Check.html#a067ee17412e800f03802fa9517685732a3450a9712780ac26b071f9da4288a396">Size</a> = 0;</div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160; </div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;    <span class="comment">// The alignment of this access.</span></div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;    <a class="code" href="ELFObjHandler_8cpp.html#a043cdaf7b89aaeeb127be5d93411637f">Align</a> Alignment;</div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;  };</div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;<span class="comment">  /// A type for holding instructions and their stride descriptors.</span></div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;<span class="comment"></span>  <span class="keyword">using</span> StrideEntry = std::pair&lt;Instruction *, StrideDescriptor&gt;;</div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;<span class="comment">  /// Create a new interleave group with the given instruction \p Instr,</span></div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;<span class="comment">  /// stride \p Stride and alignment \p Align.</span></div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;<span class="comment">  ///</span></div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;<span class="comment">  /// \returns the newly created interleave group.</span></div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;<span class="comment"></span>  InterleaveGroup&lt;Instruction&gt; *</div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;  createInterleaveGroup(Instruction *Instr, <span class="keywordtype">int</span> Stride, <a class="code" href="ELFObjHandler_8cpp.html#a043cdaf7b89aaeeb127be5d93411637f">Align</a> Alignment) {</div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;    <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(!InterleaveGroupMap.<a class="code" href="classllvm_1_1DenseMapBase.html#a53408c95a7bfb5443b43fb2134c3eb23">count</a>(Instr) &amp;&amp;</div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;           <span class="stringliteral">&quot;Already in an interleaved access group&quot;</span>);</div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;    InterleaveGroupMap[Instr] =</div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;        <span class="keyword">new</span> InterleaveGroup&lt;Instruction&gt;(Instr, Stride, Alignment);</div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;    InterleaveGroups.<a class="code" href="classllvm_1_1SmallPtrSetImpl.html#a6bc6fb89fe2e91c25559a8631f56e27e">insert</a>(InterleaveGroupMap[Instr]);</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;    <span class="keywordflow">return</span> InterleaveGroupMap[Instr];</div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;  }</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;<span class="comment">  /// Release the group and remove all the relationships.</span></div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> releaseGroup(InterleaveGroup&lt;Instruction&gt; *Group) {</div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code" href="lib_2Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a> = 0; <a class="code" href="lib_2Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a> &lt; Group-&gt;getFactor(); <a class="code" href="lib_2Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a>++)</div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;      <span class="keywordflow">if</span> (Instruction *Member = Group-&gt;getMember(<a class="code" href="lib_2Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a>))</div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;        InterleaveGroupMap.<a class="code" href="classllvm_1_1DenseMapBase.html#a1eb8504bab5f794778d82db6ac829923">erase</a>(Member);</div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160; </div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;    InterleaveGroups.<a class="code" href="classllvm_1_1SmallPtrSetImpl.html#a11045c7973ab24a8d6315b61fa337d4e">erase</a>(Group);</div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;    <span class="keyword">delete</span> Group;</div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;  }</div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;<span class="comment">  /// Collect all the accesses with a constant stride in program order.</span></div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> collectConstStrideAccesses(</div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;      MapVector&lt;Instruction *, StrideDescriptor&gt; &amp;AccessStrideInfo,</div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacellvm.html#a16c2d9dca68e87344796fd3d394005b6">ValueToValueMap</a> &amp;Strides);</div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;<span class="comment">  /// Returns true if \p Stride is allowed in an interleaved group.</span></div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;<span class="comment"></span>  <span class="keyword">static</span> <span class="keywordtype">bool</span> isStrided(<span class="keywordtype">int</span> Stride);</div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;<span class="comment">  /// Returns true if \p BB is a predicated block.</span></div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> isPredicated(<a class="code" href="namespacellvm_1_1ISD.html#a22ea9cec080dd5f4f47ba234c2f59110a8472e46f9e4db168c5610ecdfb05dbaf">BasicBlock</a> *<a class="code" href="lib_2CodeGen_2README_8txt.html#a09776db24cf586ec9f1e18f3bae14099">BB</a>)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1LoopAccessInfo.html#aa67d22298695c49e80b79cb8a271928b">LoopAccessInfo::blockNeedsPredication</a>(<a class="code" href="lib_2CodeGen_2README_8txt.html#a09776db24cf586ec9f1e18f3bae14099">BB</a>, TheLoop, DT);</div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;  }</div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;<span class="comment">  /// Returns true if LoopAccessInfo can be used for dependence queries.</span></div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> areDependencesValid()<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;    <span class="keywordflow">return</span> LAI &amp;&amp; LAI-&gt;<a class="code" href="classllvm_1_1LoopAccessInfo.html#acbe724e001e95a061672be1975932c0b">getDepChecker</a>().<a class="code" href="classllvm_1_1MemoryDepChecker.html#ae53d34947eb05175be6aa8ddf8cbf8dd">getDependences</a>();</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;  }</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;<span class="comment">  /// Returns true if memory accesses \p A and \p B can be reordered, if</span></div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;<span class="comment">  /// necessary, when constructing interleaved groups.</span></div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;<span class="comment">  ///</span></div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;<span class="comment">  /// \p A must precede \p B in program order. We return false if reordering is</span></div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;<span class="comment">  /// not necessary or is prevented because \p A and \p B may be dependent.</span></div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> canReorderMemAccessesForInterleavedGroups(StrideEntry *<a class="code" href="README__ALTIVEC_8txt.html#a015846b6188ce15e08cd94c74a9df1a3">A</a>,</div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;                                                 StrideEntry *<a class="code" href="BuiltinGCs_8cpp.html#a7abf5fb4071cb25dbce06dfb5ee3c937">B</a>)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;    <span class="comment">// Code motion for interleaved accesses can potentially hoist strided loads</span></div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;    <span class="comment">// and sink strided stores. The code below checks the legality of the</span></div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;    <span class="comment">// following two conditions:</span></div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;    <span class="comment">// 1. Potentially moving a strided load (B) before any store (A) that</span></div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;    <span class="comment">//    precedes B, or</span></div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;    <span class="comment">// 2. Potentially moving a strided store (A) after any load or store (B)</span></div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;    <span class="comment">//    that A precedes.</span></div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;    <span class="comment">// It&#39;s legal to reorder A and B if we know there isn&#39;t a dependence from A</span></div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;    <span class="comment">// to B. Note that this determination is conservative since some</span></div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;    <span class="comment">// dependences could potentially be reordered safely.</span></div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160; </div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;    <span class="comment">// A is potentially the source of a dependence.</span></div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;    <span class="keyword">auto</span> *Src = <a class="code" href="README__ALTIVEC_8txt.html#a015846b6188ce15e08cd94c74a9df1a3">A</a>-&gt;first;</div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;    <span class="keyword">auto</span> SrcDes = <a class="code" href="README__ALTIVEC_8txt.html#a015846b6188ce15e08cd94c74a9df1a3">A</a>-&gt;second;</div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160; </div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;    <span class="comment">// B is potentially the sink of a dependence.</span></div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;    <span class="keyword">auto</span> *<a class="code" href="namespacellvm_1_1cl.html#ac96f30ba8b117dbd380b88ab8a03732ba1e82b710efc2f25cc275e53b3833e6fa">Sink</a> = <a class="code" href="BuiltinGCs_8cpp.html#a7abf5fb4071cb25dbce06dfb5ee3c937">B</a>-&gt;first;</div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;    <span class="keyword">auto</span> SinkDes = <a class="code" href="BuiltinGCs_8cpp.html#a7abf5fb4071cb25dbce06dfb5ee3c937">B</a>-&gt;second;</div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160; </div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;    <span class="comment">// Code motion for interleaved accesses can&#39;t violate WAR dependences.</span></div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;    <span class="comment">// Thus, reordering is legal if the source isn&#39;t a write.</span></div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;    <span class="keywordflow">if</span> (!Src-&gt;mayWriteToMemory())</div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160; </div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;    <span class="comment">// At least one of the accesses must be strided.</span></div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;    <span class="keywordflow">if</span> (!isStrided(SrcDes.Stride) &amp;&amp; !isStrided(SinkDes.Stride))</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160; </div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;    <span class="comment">// If dependence information is not available from LoopAccessInfo,</span></div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;    <span class="comment">// conservatively assume the instructions can&#39;t be reordered.</span></div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;    <span class="keywordflow">if</span> (!areDependencesValid())</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160; </div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;    <span class="comment">// If we know there is a dependence from source to sink, assume the</span></div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;    <span class="comment">// instructions can&#39;t be reordered. Otherwise, reordering is legal.</span></div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;    <span class="keywordflow">return</span> Dependences.<a class="code" href="classllvm_1_1DenseMapBase.html#a0c047f127ed4380a6f383d70bec4eb94">find</a>(Src) == Dependences.<a class="code" href="classllvm_1_1DenseMapBase.html#a65520b9c67759099e313d0f4e7b5ff9e">end</a>() ||</div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;           !Dependences.<a class="code" href="classllvm_1_1DenseMapBase.html#a0b2ca98dc28c61793ff5c90d23e5f14e">lookup</a>(Src).count(<a class="code" href="namespacellvm_1_1cl.html#ac96f30ba8b117dbd380b88ab8a03732ba1e82b710efc2f25cc275e53b3833e6fa">Sink</a>);</div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;  }</div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;<span class="comment">  /// Collect the dependences from LoopAccessInfo.</span></div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;<span class="comment">  ///</span></div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;<span class="comment">  /// We process the dependences once during the interleaved access analysis to</span></div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;<span class="comment">  /// enable constant-time dependence queries.</span></div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> collectDependences() {</div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;    <span class="keywordflow">if</span> (!areDependencesValid())</div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;      <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;    <span class="keyword">auto</span> *Deps = LAI-&gt;<a class="code" href="classllvm_1_1LoopAccessInfo.html#acbe724e001e95a061672be1975932c0b">getDepChecker</a>().<a class="code" href="classllvm_1_1MemoryDepChecker.html#ae53d34947eb05175be6aa8ddf8cbf8dd">getDependences</a>();</div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> Dep : *Deps)</div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;      Dependences[Dep.getSource(*LAI)].<a class="code" href="classllvm_1_1DenseMapBase.html#a99f811d53704275b4158c62a2dd138d9">insert</a>(Dep.getDestination(*LAI));</div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;  }</div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;};</div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160; </div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;} <span class="comment">// llvm namespace</span></div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160; </div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;<span class="preprocessor">#endif</span></div>
</div><!-- fragment --></div><!-- contents -->
<div class="ttc" id="anamespacellvm_1_1Check_html_a067ee17412e800f03802fa9517685732a3450a9712780ac26b071f9da4288a396"><div class="ttname"><a href="namespacellvm_1_1Check.html#a067ee17412e800f03802fa9517685732a3450a9712780ac26b071f9da4288a396">llvm::Check::Size</a></div><div class="ttdeci">@ Size</div><div class="ttdef"><b>Definition:</b> <a href="FileCheck_8h_source.html#l00074">FileCheck.h:73</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="lib_2Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">i</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00029">README.txt:29</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleaveGroup_html_aa311eadfce08b1fa5cf55c6c2008bb47"><div class="ttname"><a href="classllvm_1_1InterleaveGroup.html#aa311eadfce08b1fa5cf55c6c2008bb47">llvm::InterleaveGroup::getAlign</a></div><div class="ttdeci">Align getAlign() const</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00602">VectorUtils.h:602</a></div></div>
<div class="ttc" id="astructllvm_1_1VFInfo_html_ad9bb08bdbfc73cf77e85c835840baf10"><div class="ttname"><a href="structllvm_1_1VFInfo.html#ad9bb08bdbfc73cf77e85c835840baf10">llvm::VFInfo::Shape</a></div><div class="ttdeci">VFShape Shape</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00124">VectorUtils.h:124</a></div></div>
<div class="ttc" id="anamespacellvm_html"><div class="ttname"><a href="namespacellvm.html">llvm</a></div><div class="ttdoc">--------------------- PointerInfo ------------------------------------</div><div class="ttdef"><b>Definition:</b> <a href="AllocatorList_8h_source.html#l00023">AllocatorList.h:23</a></div></div>
<div class="ttc" id="anamespacellvm_html_a961f14c05fb26ae34f8dabdd2013b7d6"><div class="ttname"><a href="namespacellvm.html#a961f14c05fb26ae34f8dabdd2013b7d6">llvm::maskIsAllOneOrUndef</a></div><div class="ttdeci">bool maskIsAllOneOrUndef(Value *Mask)</div><div class="ttdoc">Given a mask vector of i1, Return true if all of the elements of this predicate mask are known to be ...</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00906">VectorUtils.cpp:906</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ac88fe1d3a61b056a4f64fbbb156a62ff"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ac88fe1d3a61b056a4f64fbbb156a62ff">M</a></div><div class="ttdeci">We currently emits eax Perhaps this is what we really should generate is Is imull three or four cycles eax eax The current instruction priority is based on pattern complexity The former is more complex because it folds a load so the latter will not be emitted Perhaps we should use AddedComplexity to give LEA32r a higher priority We should always try to match LEA first since the LEA matching code does some estimate to determine whether the match is profitable if we care more about code then imull is better It s two bytes shorter than movl leal On a Pentium M</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00252">README.txt:252</a></div></div>
<div class="ttc" id="aclassllvm_1_1Instruction_html_a4ba3a5be6c0e9b9e8a525de055836733"><div class="ttname"><a href="classllvm_1_1Instruction.html#a4ba3a5be6c0e9b9e8a525de055836733">llvm::Instruction::getModule</a></div><div class="ttdeci">const Module * getModule() const</div><div class="ttdoc">Return the module owning the function this instruction belongs to or nullptr it the function does not...</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Instruction_8cpp_source.html#l00066">Instruction.cpp:66</a></div></div>
<div class="ttc" id="astructllvm_1_1VFParameter_html_a94f0b487dcd5db6130afd9ad8c46c091"><div class="ttname"><a href="structllvm_1_1VFParameter.html#a94f0b487dcd5db6130afd9ad8c46c091">llvm::VFParameter::Alignment</a></div><div class="ttdeci">Align Alignment</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00066">VectorUtils.h:66</a></div></div>
<div class="ttc" id="anamespacellvm_html_ad1a91b49e0c092818a0b82f6cc130a1b"><div class="ttname"><a href="namespacellvm.html#ad1a91b49e0c092818a0b82f6cc130a1b">llvm::make_range</a></div><div class="ttdeci">iterator_range&lt; T &gt; make_range(T x, T y)</div><div class="ttdoc">Convenience function for iterating over sub-ranges.</div><div class="ttdef"><b>Definition:</b> <a href="iterator__range_8h_source.html#l00053">iterator_range.h:53</a></div></div>
<div class="ttc" id="anamespacellvm_html_add480f2ed87faa59c16d4c01ffb4bf39a57dea6f5039281b7fee517fc43bf3110"><div class="ttname"><a href="namespacellvm.html#add480f2ed87faa59c16d4c01ffb4bf39a57dea6f5039281b7fee517fc43bf3110">llvm::VFParamKind::Vector</a></div><div class="ttdeci">@ Vector</div></div>
<div class="ttc" id="aclassllvm_1_1SmallPtrSetImpl_html_a11045c7973ab24a8d6315b61fa337d4e"><div class="ttname"><a href="classllvm_1_1SmallPtrSetImpl.html#a11045c7973ab24a8d6315b61fa337d4e">llvm::SmallPtrSetImpl::erase</a></div><div class="ttdeci">bool erase(PtrType Ptr)</div><div class="ttdoc">erase - If the set contains the specified pointer, remove it and return true, otherwise return false.</div><div class="ttdef"><b>Definition:</b> <a href="SmallPtrSet_8h_source.html#l00378">SmallPtrSet.h:378</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleaveGroup_html_ad2398638cf12a8318566a3fc6cc0e771"><div class="ttname"><a href="classllvm_1_1InterleaveGroup.html#ad2398638cf12a8318566a3fc6cc0e771">llvm::InterleaveGroup::insertMember</a></div><div class="ttdeci">bool insertMember(InstTy *Instr, int32_t Index, Align NewAlign)</div><div class="ttdoc">Try to insert a new member Instr with index Index and alignment NewAlign.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00610">VectorUtils.h:610</a></div></div>
<div class="ttc" id="aclassllvm_1_1ElementCount_html"><div class="ttname"><a href="classllvm_1_1ElementCount.html">llvm::ElementCount</a></div><div class="ttdef"><b>Definition:</b> <a href="TypeSize_8h_source.html#l00386">TypeSize.h:386</a></div></div>
<div class="ttc" id="anamespacellvm_html_a11c66d01880f53332fc7ad53f565b039"><div class="ttname"><a href="namespacellvm.html#a11c66d01880f53332fc7ad53f565b039">llvm::getVectorIntrinsicIDForCall</a></div><div class="ttdeci">Intrinsic::ID getVectorIntrinsicIDForCall(const CallInst *CI, const TargetLibraryInfo *TLI)</div><div class="ttdoc">Returns intrinsic ID for call.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00130">VectorUtils.cpp:130</a></div></div>
<div class="ttc" id="aclassllvm_1_1Function_html"><div class="ttname"><a href="classllvm_1_1Function.html">llvm::Function</a></div><div class="ttdef"><b>Definition:</b> <a href="Function_8h_source.html#l00061">Function.h:62</a></div></div>
<div class="ttc" id="aclassllvm_1_1Loop_html"><div class="ttname"><a href="classllvm_1_1Loop.html">llvm::Loop</a></div><div class="ttdoc">Represents a single loop in the control flow graph.</div><div class="ttdef"><b>Definition:</b> <a href="LoopInfo_8h_source.html#l00530">LoopInfo.h:530</a></div></div>
<div class="ttc" id="anamespacellvm_html_ac099f60f123281d4abe0c1589c5f3812"><div class="ttname"><a href="namespacellvm.html#ac099f60f123281d4abe0c1589c5f3812">llvm::getGEPInductionOperand</a></div><div class="ttdeci">unsigned getGEPInductionOperand(const GetElementPtrInst *Gep)</div><div class="ttdoc">Find the operand of the GEP that should be checked for consecutive stores.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00147">VectorUtils.cpp:147</a></div></div>
<div class="ttc" id="aclassllvm_1_1DenseMapBase_html_a0b2ca98dc28c61793ff5c90d23e5f14e"><div class="ttname"><a href="classllvm_1_1DenseMapBase.html#a0b2ca98dc28c61793ff5c90d23e5f14e">llvm::DenseMapBase::lookup</a></div><div class="ttdeci">ValueT lookup(const_arg_type_t&lt; KeyT &gt; Val) const</div><div class="ttdoc">lookup - Return the entry for the specified key, or a default constructed value if no such entry exis...</div><div class="ttdef"><b>Definition:</b> <a href="DenseMap_8h_source.html#l00197">DenseMap.h:197</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a63d206a063eefcdf8c318ded97b65020"><div class="ttname"><a href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a></div><div class="ttdeci">This currently compiles esp xmm0 movsd esp eax eax esp ret We should use not the dag combiner This is because dagcombine2 needs to be able to see through the X86ISD::Wrapper which DAGCombine can t really do The code for turning x load into a single vector load is target independent and should be moved to the dag combiner The code for turning x load into a vector load can only handle a direct load from a global or a direct load from the stack It should be generalized to handle any load from P</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00411">README-SSE.txt:411</a></div></div>
<div class="ttc" id="anamespacellvm_html_a1a0a402f51b5d937bbd3accc7bb354ab"><div class="ttname"><a href="namespacellvm.html#a1a0a402f51b5d937bbd3accc7bb354ab">llvm::possiblyDemandedEltsInMask</a></div><div class="ttdeci">APInt possiblyDemandedEltsInMask(Value *Mask)</div><div class="ttdoc">Given a mask vector of the form &lt;Y x i1&gt;, return an APInt (of bitwidth Y) for each lane which may be ...</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00934">VectorUtils.cpp:934</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleaveGroup_html_a53b02fefd57973cff5c9bc7a7badde56"><div class="ttname"><a href="classllvm_1_1InterleaveGroup.html#a53b02fefd57973cff5c9bc7a7badde56">llvm::InterleaveGroup::InterleaveGroup</a></div><div class="ttdeci">InterleaveGroup(uint32_t Factor, bool Reverse, Align Alignment)</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00587">VectorUtils.h:587</a></div></div>
<div class="ttc" id="aclassllvm_1_1PredicatedScalarEvolution_html"><div class="ttname"><a href="classllvm_1_1PredicatedScalarEvolution.html">llvm::PredicatedScalarEvolution</a></div><div class="ttdoc">An interface layer with SCEV used to manage how we see SCEV expressions for values in the context of ...</div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8h_source.html#l02175">ScalarEvolution.h:2175</a></div></div>
<div class="ttc" id="anamespacellvm_html_abe2c24a8dc2fb979e8e54e15f088169ca88183b946cc5f0e8c96b2e66e1c74a7e"><div class="ttname"><a href="namespacellvm.html#abe2c24a8dc2fb979e8e54e15f088169ca88183b946cc5f0e8c96b2e66e1c74a7e">llvm::VFISAKind::Unknown</a></div><div class="ttdeci">@ Unknown</div></div>
<div class="ttc" id="aclassllvm_1_1SmallVector_html"><div class="ttname"><a href="classllvm_1_1SmallVector.html">llvm::SmallVector</a></div><div class="ttdoc">This is a 'vector' (really, a variable-sized array), optimized for the case when the array is small.</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l01168">SmallVector.h:1169</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleavedAccessInfo_html_afdb6529eb70fb9aed0036ebc1a864c49"><div class="ttname"><a href="classllvm_1_1InterleavedAccessInfo.html#afdb6529eb70fb9aed0036ebc1a864c49">llvm::InterleavedAccessInfo::InterleavedAccessInfo</a></div><div class="ttdeci">InterleavedAccessInfo(PredicatedScalarEvolution &amp;PSE, Loop *L, DominatorTree *DT, LoopInfo *LI, const LoopAccessInfo *LAI)</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00731">VectorUtils.h:731</a></div></div>
<div class="ttc" id="anamespacellvm_html_a48fc95f799e976fb8bf571d61e6337f5"><div class="ttname"><a href="namespacellvm.html#a48fc95f799e976fb8bf571d61e6337f5">llvm::getSplatValue</a></div><div class="ttdeci">Value * getSplatValue(const Value *V)</div><div class="ttdoc">Get splat value if the input is a splat vector or return nullptr.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00360">VectorUtils.cpp:360</a></div></div>
<div class="ttc" id="aLoopAccessAnalysis_8h_html"><div class="ttname"><a href="LoopAccessAnalysis_8h.html">LoopAccessAnalysis.h</a></div></div>
<div class="ttc" id="anamespacellvm_1_1VFABI_html_a8adf44ad04562ff150b0e8e352a38d46"><div class="ttname"><a href="namespacellvm_1_1VFABI.html#a8adf44ad04562ff150b0e8e352a38d46">llvm::VFABI::getVectorVariantNames</a></div><div class="ttdeci">void getVectorVariantNames(const CallInst &amp;CI, SmallVectorImpl&lt; std::string &gt; &amp;VariantMappings)</div><div class="ttdoc">Populates a set of strings representing the Vector Function ABI variants associated to the CallInst C...</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l01326">VectorUtils.cpp:1326</a></div></div>
<div class="ttc" id="aMapVector_8h_html"><div class="ttname"><a href="MapVector_8h.html">MapVector.h</a></div></div>
<div class="ttc" id="anamespacellvm_html_ac43e0b6cbbe1e0d8988e9c5482573a92"><div class="ttname"><a href="namespacellvm.html#ac43e0b6cbbe1e0d8988e9c5482573a92">llvm::maskIsAllZeroOrUndef</a></div><div class="ttdeci">bool maskIsAllZeroOrUndef(Value *Mask)</div><div class="ttdoc">Given a mask vector of i1, Return true if all of the elements of this predicate mask are known to be ...</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00880">VectorUtils.cpp:880</a></div></div>
<div class="ttc" id="astructllvm_1_1VFParameter_html_a8c8f86edc9db58476d6b16903cd403ac"><div class="ttname"><a href="structllvm_1_1VFParameter.html#a8c8f86edc9db58476d6b16903cd403ac">llvm::VFParameter::ParamKind</a></div><div class="ttdeci">VFParamKind ParamKind</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00064">VectorUtils.h:64</a></div></div>
<div class="ttc" id="aclassllvm_1_1DominatorTree_html"><div class="ttname"><a href="classllvm_1_1DominatorTree.html">llvm::DominatorTree</a></div><div class="ttdoc">Concrete subclass of DominatorTreeBase that is used to compute a normal dominator tree.</div><div class="ttdef"><b>Definition:</b> <a href="Dominators_8h_source.html#l00151">Dominators.h:151</a></div></div>
<div class="ttc" id="astructllvm_1_1VFShape_html_a0ff6e282ab0c2d186052d7654441ada8"><div class="ttname"><a href="structllvm_1_1VFShape.html#a0ff6e282ab0c2d186052d7654441ada8">llvm::VFShape::getScalarShape</a></div><div class="ttdeci">static VFShape getScalarShape(const CallInst &amp;CI)</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00099">VectorUtils.h:99</a></div></div>
<div class="ttc" id="aclassllvm_1_1DenseMapBase_html_a1eb8504bab5f794778d82db6ac829923"><div class="ttname"><a href="classllvm_1_1DenseMapBase.html#a1eb8504bab5f794778d82db6ac829923">llvm::DenseMapBase&lt; DenseMap&lt; KeyT, ValueT, DenseMapInfo&lt; KeyT &gt;, llvm::detail::DenseMapPair&lt; KeyT, ValueT &gt; &gt;, KeyT, ValueT, DenseMapInfo&lt; KeyT &gt;, llvm::detail::DenseMapPair&lt; KeyT, ValueT &gt; &gt;::erase</a></div><div class="ttdeci">bool erase(const KeyT &amp;Val)</div><div class="ttdef"><b>Definition:</b> <a href="DenseMap_8h_source.html#l00302">DenseMap.h:302</a></div></div>
<div class="ttc" id="anamespacellvm_html_af7b6ae12af3578f7a20ccc11a4458f9f"><div class="ttname"><a href="namespacellvm.html#af7b6ae12af3578f7a20ccc11a4458f9f">llvm::computeMinimumValueSizes</a></div><div class="ttdeci">MapVector&lt; Instruction *, uint64_t &gt; computeMinimumValueSizes(ArrayRef&lt; BasicBlock * &gt; Blocks, DemandedBits &amp;DB, const TargetTransformInfo *TTI=nullptr)</div><div class="ttdoc">Compute a map of integer instructions to their minimum legal type size.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00494">VectorUtils.cpp:494</a></div></div>
<div class="ttc" id="anamespacellvm_html_a1eb5609345b906d024fbf9e4bc1adc06afe578efb7ca235af77fb0eef7edcf639"><div class="ttname"><a href="namespacellvm.html#a1eb5609345b906d024fbf9e4bc1adc06afe578efb7ca235af77fb0eef7edcf639">llvm::Depth</a></div><div class="ttdeci">@ Depth</div><div class="ttdef"><b>Definition:</b> <a href="SIMachineScheduler_8h_source.html#l00034">SIMachineScheduler.h:34</a></div></div>
<div class="ttc" id="astructllvm_1_1VFParameter_html_a967df74e8d0246a66ca1a27ba50daa8a"><div class="ttname"><a href="structllvm_1_1VFParameter.html#a967df74e8d0246a66ca1a27ba50daa8a">llvm::VFParameter::ParamPos</a></div><div class="ttdeci">unsigned ParamPos</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00063">VectorUtils.h:63</a></div></div>
<div class="ttc" id="anamespacellvm_html_aa91449ed55cd3c525a3438252573527a"><div class="ttname"><a href="namespacellvm.html#aa91449ed55cd3c525a3438252573527a">llvm::narrowShuffleMaskElts</a></div><div class="ttdeci">void narrowShuffleMaskElts(int Scale, ArrayRef&lt; int &gt; Mask, SmallVectorImpl&lt; int &gt; &amp;ScaledMask)</div><div class="ttdoc">Replace each shuffle mask index with the scaled sequential indices for an equivalent mask of narrowed...</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00421">VectorUtils.cpp:421</a></div></div>
<div class="ttc" id="aclassllvm_1_1Type_html"><div class="ttname"><a href="classllvm_1_1Type.html">llvm::Type</a></div><div class="ttdoc">The instances of the Type class are immutable: once they are created, they are never changed.</div><div class="ttdef"><b>Definition:</b> <a href="Type_8h_source.html#l00045">Type.h:45</a></div></div>
<div class="ttc" id="anamespacellvm_html_a7f585f542b02a8f683f3df717d631755"><div class="ttname"><a href="namespacellvm.html#a7f585f542b02a8f683f3df717d631755">llvm::getUniqueCastUse</a></div><div class="ttdeci">Value * getUniqueCastUse(Value *Ptr, Loop *Lp, Type *Ty)</div><div class="ttdoc">If a value has only one user that is a CastInst, return it.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00188">VectorUtils.cpp:188</a></div></div>
<div class="ttc" id="aclassllvm_1_1Optional_html"><div class="ttname"><a href="classllvm_1_1Optional.html">llvm::Optional</a></div><div class="ttdef"><b>Definition:</b> <a href="Optional_8h_source.html#l00238">Optional.h:238</a></div></div>
<div class="ttc" id="aclassllvm_1_1DenseMapBase_html_a53408c95a7bfb5443b43fb2134c3eb23"><div class="ttname"><a href="classllvm_1_1DenseMapBase.html#a53408c95a7bfb5443b43fb2134c3eb23">llvm::DenseMapBase&lt; DenseMap&lt; KeyT, ValueT, DenseMapInfo&lt; KeyT &gt;, llvm::detail::DenseMapPair&lt; KeyT, ValueT &gt; &gt;, KeyT, ValueT, DenseMapInfo&lt; KeyT &gt;, llvm::detail::DenseMapPair&lt; KeyT, ValueT &gt; &gt;::count</a></div><div class="ttdeci">size_type count(const_arg_type_t&lt; KeyT &gt; Val) const</div><div class="ttdoc">Return 1 if the specified key is in the map, 0 otherwise.</div><div class="ttdef"><b>Definition:</b> <a href="DenseMap_8h_source.html#l00145">DenseMap.h:145</a></div></div>
<div class="ttc" id="aclassllvm_1_1SmallPtrSet_html"><div class="ttname"><a href="classllvm_1_1SmallPtrSet.html">llvm::SmallPtrSet</a></div><div class="ttdoc">SmallPtrSet - This class implements a set which is optimized for holding SmallSize or less elements.</div><div class="ttdef"><b>Definition:</b> <a href="SmallPtrSet_8h_source.html#l00449">SmallPtrSet.h:449</a></div></div>
<div class="ttc" id="anamespacellvm_1_1MipsISD_html_a422daf9aa810935178671306b651d69ba366e1eac31eeb1a1892d62ccfc0c8cf8"><div class="ttname"><a href="namespacellvm_1_1MipsISD.html#a422daf9aa810935178671306b651d69ba366e1eac31eeb1a1892d62ccfc0c8cf8">llvm::MipsISD::Ret</a></div><div class="ttdeci">@ Ret</div><div class="ttdef"><b>Definition:</b> <a href="MipsISelLowering_8h_source.html#l00116">MipsISelLowering.h:116</a></div></div>
<div class="ttc" id="anamespacellvm_html_a48a6deb3e714d54e75caadcf84b0ca76"><div class="ttname"><a href="namespacellvm.html#a48a6deb3e714d54e75caadcf84b0ca76">llvm::propagateMetadata</a></div><div class="ttdeci">Instruction * propagateMetadata(Instruction *I, ArrayRef&lt; Value * &gt; VL)</div><div class="ttdoc">Specifically, let Kinds = [MD_tbaa, MD_alias_scope, MD_noalias, MD_fpmath, MD_nontemporal,...</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00720">VectorUtils.cpp:720</a></div></div>
<div class="ttc" id="anamespacellvm_1_1VFABI_html_af33ac7943ba16e891cd1b6e307029301"><div class="ttname"><a href="namespacellvm_1_1VFABI.html#af33ac7943ba16e891cd1b6e307029301">llvm::VFABI::_LLVM_</a></div><div class="ttdeci">static constexpr char const  * _LLVM_</div><div class="ttdoc">LLVM Internal VFABI ISA token for vector functions.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00132">VectorUtils.h:132</a></div></div>
<div class="ttc" id="astructllvm_1_1VFShape_html_a82591e3e596fe99aebc1e2f3316ef41c"><div class="ttname"><a href="structllvm_1_1VFShape.html#a82591e3e596fe99aebc1e2f3316ef41c">llvm::VFShape::Parameters</a></div><div class="ttdeci">SmallVector&lt; VFParameter, 8 &gt; Parameters</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00084">VectorUtils.h:84</a></div></div>
<div class="ttc" id="aclassllvm_1_1Module_html_a209a615a3a32241323420cca24b5520a"><div class="ttname"><a href="classllvm_1_1Module.html#a209a615a3a32241323420cca24b5520a">llvm::Module::getFunction</a></div><div class="ttdeci">Function * getFunction(StringRef Name) const</div><div class="ttdoc">Look up the specified function in the module symbol table.</div><div class="ttdef"><b>Definition:</b> <a href="Module_8cpp_source.html#l00178">Module.cpp:178</a></div></div>
<div class="ttc" id="anamespacellvm_1_1BitmaskEnumDetail_html_ad9273b0ee6c5e0f2367e3136c1503811"><div class="ttname"><a href="namespacellvm_1_1BitmaskEnumDetail.html#ad9273b0ee6c5e0f2367e3136c1503811">llvm::BitmaskEnumDetail::Mask</a></div><div class="ttdeci">std::underlying_type_t&lt; E &gt; Mask()</div><div class="ttdoc">Get a bitmask with 1s in all places up to the high-order bit of E's largest value.</div><div class="ttdef"><b>Definition:</b> <a href="BitmaskEnum_8h_source.html#l00080">BitmaskEnum.h:80</a></div></div>
<div class="ttc" id="anamespacellvm_html_ab307a287351370b59786ef96c73738cb"><div class="ttname"><a href="namespacellvm.html#ab307a287351370b59786ef96c73738cb">llvm::uniteAccessGroups</a></div><div class="ttdeci">MDNode * uniteAccessGroups(MDNode *AccGroups1, MDNode *AccGroups2)</div><div class="ttdoc">Compute the union of two access-group lists.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00652">VectorUtils.cpp:652</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleaveGroup_html"><div class="ttname"><a href="classllvm_1_1InterleaveGroup.html">llvm::InterleaveGroup</a></div><div class="ttdoc">The group of interleaved loads/stores sharing the same stride and close to each other.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00585">VectorUtils.h:585</a></div></div>
<div class="ttc" id="anamespacellvm_html_abe2c24a8dc2fb979e8e54e15f088169c"><div class="ttname"><a href="namespacellvm.html#abe2c24a8dc2fb979e8e54e15f088169c">llvm::VFISAKind</a></div><div class="ttdeci">VFISAKind</div><div class="ttdoc">Describes the type of Instruction Set Architecture.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00044">VectorUtils.h:44</a></div></div>
<div class="ttc" id="aclassllvm_1_1Optional_html_ab8f06efe88f146384116a787058ab420"><div class="ttname"><a href="classllvm_1_1Optional.html#ab8f06efe88f146384116a787058ab420">llvm::Optional::hasValue</a></div><div class="ttdeci">constexpr bool hasValue() const</div><div class="ttdef"><b>Definition:</b> <a href="Optional_8h_source.html#l00288">Optional.h:288</a></div></div>
<div class="ttc" id="astructllvm_1_1VFShape_html_a73ecf8e2dc91bc82db95710da747b5ab"><div class="ttname"><a href="structllvm_1_1VFShape.html#a73ecf8e2dc91bc82db95710da747b5ab">llvm::VFShape::hasValidParameterList</a></div><div class="ttdeci">bool hasValidParameterList() const</div><div class="ttdoc">Sanity check on the Parameters in the VFShape.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l01349">VectorUtils.cpp:1349</a></div></div>
<div class="ttc" id="aclassllvm_1_1ElementCount_html_add8ce9d6756a651e5f26d7c8c5796e2c"><div class="ttname"><a href="classllvm_1_1ElementCount.html#add8ce9d6756a651e5f26d7c8c5796e2c">llvm::ElementCount::isScalar</a></div><div class="ttdeci">bool isScalar() const</div><div class="ttdoc">Counting predicates.</div><div class="ttdef"><b>Definition:</b> <a href="TypeSize_8h_source.html#l00396">TypeSize.h:396</a></div></div>
<div class="ttc" id="aInjectTLIMappings_8cpp_html_a3d23fb8c590cd607d4b25a05e31c69f5"><div class="ttname"><a href="InjectTLIMappings_8cpp.html#a3d23fb8c590cd607d4b25a05e31c69f5">Mappings</a></div><div class="ttdeci">Inject TLI Mappings</div><div class="ttdef"><b>Definition:</b> <a href="InjectTLIMappings_8cpp_source.html#l00172">InjectTLIMappings.cpp:172</a></div></div>
<div class="ttc" id="anamespacellvm_1_1VFABI_html_a11875601ee512fa1f5cf6b6354c8def9"><div class="ttname"><a href="namespacellvm_1_1VFABI.html#a11875601ee512fa1f5cf6b6354c8def9">llvm::VFABI::MappingsAttrName</a></div><div class="ttdeci">static constexpr char const  * MappingsAttrName</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00193">VectorUtils.h:193</a></div></div>
<div class="ttc" id="astructllvm_1_1DenseMapInfo_html"><div class="ttname"><a href="structllvm_1_1DenseMapInfo.html">llvm::DenseMapInfo</a></div><div class="ttdef"><b>Definition:</b> <a href="DenseMapInfo_8h_source.html#l00043">DenseMapInfo.h:43</a></div></div>
<div class="ttc" id="anamespacellvm_html_a6339f2ad6701dc229c34ca4305596d3a"><div class="ttname"><a href="namespacellvm.html#a6339f2ad6701dc229c34ca4305596d3a">llvm::isSplatValue</a></div><div class="ttdeci">bool isSplatValue(const Value *V, int Index=-1, unsigned Depth=0)</div><div class="ttdoc">Return true if each element of the vector value V is poisoned or equal to every other non-poisoned el...</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00375">VectorUtils.cpp:375</a></div></div>
<div class="ttc" id="anamespacellvm_1_1VFABI_html_a64353c34cb9dba37aa99ed7bbe63c903"><div class="ttname"><a href="namespacellvm_1_1VFABI.html#a64353c34cb9dba37aa99ed7bbe63c903">llvm::VFABI::mangleTLIVectorName</a></div><div class="ttdeci">std::string mangleTLIVectorName(StringRef VectorName, StringRef ScalarName, unsigned numArgs, ElementCount VF)</div><div class="ttdoc">This routine mangles the given VectorName according to the LangRef specification for vector-function-...</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l01310">VectorUtils.cpp:1310</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleavedAccessInfo_html_afad01409b57e77467d7cafa03ffe3d3f"><div class="ttname"><a href="classllvm_1_1InterleavedAccessInfo.html#afad01409b57e77467d7cafa03ffe3d3f">llvm::InterleavedAccessInfo::invalidateGroupsRequiringScalarEpilogue</a></div><div class="ttdeci">void invalidateGroupsRequiringScalarEpilogue()</div><div class="ttdoc">Invalidate groups that require a scalar epilogue (due to gaps).</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l01269">VectorUtils.cpp:1269</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleaveGroup_html_aa39b702ab803808098afedd96623cd92"><div class="ttname"><a href="classllvm_1_1InterleaveGroup.html#aa39b702ab803808098afedd96623cd92">llvm::InterleaveGroup::InterleaveGroup</a></div><div class="ttdeci">InterleaveGroup(InstTy *Instr, int32_t Stride, Align Alignment)</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00591">VectorUtils.h:591</a></div></div>
<div class="ttc" id="anamespacellvm_html_add480f2ed87faa59c16d4c01ffb4bf39"><div class="ttname"><a href="namespacellvm.html#add480f2ed87faa59c16d4c01ffb4bf39">llvm::VFParamKind</a></div><div class="ttdeci">VFParamKind</div><div class="ttdoc">Describes the type of Parameters.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00025">VectorUtils.h:25</a></div></div>
<div class="ttc" id="anamespacellvm_html_aab4ac3afe77847f88a5bec4ef29e68fa"><div class="ttname"><a href="namespacellvm.html#aab4ac3afe77847f88a5bec4ef29e68fa">llvm::createInterleaveMask</a></div><div class="ttdeci">llvm::SmallVector&lt; int, 16 &gt; createInterleaveMask(unsigned VF, unsigned NumVecs)</div><div class="ttdoc">Create an interleave shuffle mask.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00795">VectorUtils.cpp:795</a></div></div>
<div class="ttc" id="astructllvm_1_1VFInfo_html_a87c240df9a221a4e18326c7adc599629"><div class="ttname"><a href="structllvm_1_1VFInfo.html#a87c240df9a221a4e18326c7adc599629">llvm::VFInfo::VectorName</a></div><div class="ttdeci">std::string VectorName</div><div class="ttdoc">Scalar Function Name.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00126">VectorUtils.h:126</a></div></div>
<div class="ttc" id="anamespacellvm_html_a3d465d135c62843160741eeddf360da9"><div class="ttname"><a href="namespacellvm.html#a3d465d135c62843160741eeddf360da9">llvm::checkedSub</a></div><div class="ttdeci">std::enable_if_t&lt; std::is_signed&lt; T &gt;::value, llvm::Optional&lt; T &gt; &gt; checkedSub(T LHS, T RHS)</div><div class="ttdoc">Subtract two signed integers LHS and RHS.</div><div class="ttdef"><b>Definition:</b> <a href="CheckedArithmetic_8h_source.html#l00057">CheckedArithmetic.h:57</a></div></div>
<div class="ttc" id="aclassllvm_1_1VFDatabase_html"><div class="ttname"><a href="classllvm_1_1VFDatabase.html">llvm::VFDatabase</a></div><div class="ttdoc">The Vector Function Database.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00208">VectorUtils.h:208</a></div></div>
<div class="ttc" id="aCheckedArithmetic_8h_html"><div class="ttname"><a href="CheckedArithmetic_8h.html">CheckedArithmetic.h</a></div></div>
<div class="ttc" id="aclassllvm_1_1LoopAccessInfo_html_aa67d22298695c49e80b79cb8a271928b"><div class="ttname"><a href="classllvm_1_1LoopAccessInfo.html#aa67d22298695c49e80b79cb8a271928b">llvm::LoopAccessInfo::blockNeedsPredication</a></div><div class="ttdeci">static bool blockNeedsPredication(BasicBlock *BB, Loop *TheLoop, DominatorTree *DT)</div><div class="ttdoc">Return true if the block BB needs to be predicated in order for the loop to be vectorized.</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l02092">LoopAccessAnalysis.cpp:2092</a></div></div>
<div class="ttc" id="anamespacellvm_html_a16c2d9dca68e87344796fd3d394005b6"><div class="ttname"><a href="namespacellvm.html#a16c2d9dca68e87344796fd3d394005b6">llvm::ValueToValueMap</a></div><div class="ttdeci">DenseMap&lt; const Value *, Value * &gt; ValueToValueMap</div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolutionExpressions_8h_source.html#l00857">ScalarEvolutionExpressions.h:857</a></div></div>
<div class="ttc" id="astructllvm_1_1VFInfo_html"><div class="ttname"><a href="structllvm_1_1VFInfo.html">llvm::VFInfo</a></div><div class="ttdoc">Holds the VFShape for a specific scalar to vector function mapping.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00123">VectorUtils.h:123</a></div></div>
<div class="ttc" id="anamespacellvm_html_aeb65ce026673a69aac75e5a7a26007b3"><div class="ttname"><a href="namespacellvm.html#aeb65ce026673a69aac75e5a7a26007b3">llvm::isTriviallyVectorizable</a></div><div class="ttdeci">bool isTriviallyVectorizable(Intrinsic::ID ID)</div><div class="ttdoc">Identify if the intrinsic is trivially vectorizable.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00044">VectorUtils.cpp:44</a></div></div>
<div class="ttc" id="anamespacellvm_html_a611d9f877de3e9402bd8f56fb10ec5a1"><div class="ttname"><a href="namespacellvm.html#a611d9f877de3e9402bd8f56fb10ec5a1">llvm::getStrideFromPointer</a></div><div class="ttdeci">Value * getStrideFromPointer(Value *Ptr, ScalarEvolution *SE, Loop *Lp)</div><div class="ttdoc">Get the stride of a pointer access in a loop.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00204">VectorUtils.cpp:204</a></div></div>
<div class="ttc" id="aclassllvm_1_1CallBase_html_a83b8c9e572130f403445c0b0f69b837c"><div class="ttname"><a href="classllvm_1_1CallBase.html#a83b8c9e572130f403445c0b0f69b837c">llvm::CallBase::getCalledFunction</a></div><div class="ttdeci">Function * getCalledFunction() const</div><div class="ttdoc">Returns the function called, or null if this is an indirect function invocation.</div><div class="ttdef"><b>Definition:</b> <a href="InstrTypes_8h_source.html#l01393">InstrTypes.h:1393</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleavedAccessInfo_html_afbe177a202a10b44c23c97acb07a1992"><div class="ttname"><a href="classllvm_1_1InterleavedAccessInfo.html#afbe177a202a10b44c23c97acb07a1992">llvm::InterleavedAccessInfo::~InterleavedAccessInfo</a></div><div class="ttdeci">~InterleavedAccessInfo()</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00736">VectorUtils.h:736</a></div></div>
<div class="ttc" id="anamespacellvm_html_a273a0d00c32d9201b643a8e36822191c"><div class="ttname"><a href="namespacellvm.html#a273a0d00c32d9201b643a8e36822191c">llvm::ToVectorTy</a></div><div class="ttdeci">Type * ToVectorTy(Type *Scalar, ElementCount EC)</div><div class="ttdoc">A helper function for converting Scalar types to vector types.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00299">VectorUtils.h:299</a></div></div>
<div class="ttc" id="anamespacellvm_1_1AMDGPU_1_1PALMD_html_af892c75285b0f64d58ca76cb73059adf"><div class="ttname"><a href="namespacellvm_1_1AMDGPU_1_1PALMD.html#af892c75285b0f64d58ca76cb73059adf">llvm::AMDGPU::PALMD::Key</a></div><div class="ttdeci">Key</div><div class="ttdoc">PAL metadata keys.</div><div class="ttdef"><b>Definition:</b> <a href="AMDGPUMetadata_8h_source.html#l00481">AMDGPUMetadata.h:481</a></div></div>
<div class="ttc" id="aBuiltinGCs_8cpp_html_a7abf5fb4071cb25dbce06dfb5ee3c937"><div class="ttname"><a href="BuiltinGCs_8cpp.html#a7abf5fb4071cb25dbce06dfb5ee3c937">B</a></div><div class="ttdeci">static GCRegistry::Add&lt; OcamlGC &gt; B(&quot;ocaml&quot;, &quot;ocaml 3.10-compatible GC&quot;)</div></div>
<div class="ttc" id="anamespacellvm_html_abe2c24a8dc2fb979e8e54e15f088169caee6ecd3e091cdefd02e783f9b9869388"><div class="ttname"><a href="namespacellvm.html#abe2c24a8dc2fb979e8e54e15f088169caee6ecd3e091cdefd02e783f9b9869388">llvm::VFISAKind::AVX2</a></div><div class="ttdeci">@ AVX2</div></div>
<div class="ttc" id="aclassllvm_1_1Instruction_html"><div class="ttname"><a href="classllvm_1_1Instruction.html">llvm::Instruction</a></div><div class="ttdef"><b>Definition:</b> <a href="IR_2Instruction_8h_source.html#l00045">Instruction.h:46</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleavedAccessInfo_html"><div class="ttname"><a href="classllvm_1_1InterleavedAccessInfo.html">llvm::InterleavedAccessInfo</a></div><div class="ttdoc">Drive the analysis of interleaved memory accesses in the loop.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00729">VectorUtils.h:729</a></div></div>
<div class="ttc" id="aCSEInfo_8cpp_html_a75f8a8519c2c9b30e7c06dc5e256fffa"><div class="ttname"><a href="CSEInfo_8cpp.html#a75f8a8519c2c9b30e7c06dc5e256fffa">Info</a></div><div class="ttdeci">Analysis containing CSE Info</div><div class="ttdef"><b>Definition:</b> <a href="CSEInfo_8cpp_source.html#l00027">CSEInfo.cpp:27</a></div></div>
<div class="ttc" id="aclassllvm_1_1MemoryDepChecker_html_ae53d34947eb05175be6aa8ddf8cbf8dd"><div class="ttname"><a href="classllvm_1_1MemoryDepChecker.html#ae53d34947eb05175be6aa8ddf8cbf8dd">llvm::MemoryDepChecker::getDependences</a></div><div class="ttdeci">const SmallVectorImpl&lt; Dependence &gt; * getDependences() const</div><div class="ttdoc">Returns the memory dependences.</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00234">LoopAccessAnalysis.h:234</a></div></div>
<div class="ttc" id="astructllvm_1_1VFShape_html"><div class="ttname"><a href="structllvm_1_1VFShape.html">llvm::VFShape</a></div><div class="ttdoc">Contains the information about the kind of vectorization available.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00082">VectorUtils.h:82</a></div></div>
<div class="ttc" id="aELFObjHandler_8cpp_html_a043cdaf7b89aaeeb127be5d93411637f"><div class="ttname"><a href="ELFObjHandler_8cpp.html#a043cdaf7b89aaeeb127be5d93411637f">Align</a></div><div class="ttdeci">uint64_t Align</div><div class="ttdef"><b>Definition:</b> <a href="ELFObjHandler_8cpp_source.html#l00083">ELFObjHandler.cpp:83</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleaveGroup_html_a776b9e4e25dda6aff28a94e69a7533e6"><div class="ttname"><a href="classllvm_1_1InterleaveGroup.html#a776b9e4e25dda6aff28a94e69a7533e6">llvm::InterleaveGroup::isReverse</a></div><div class="ttdeci">bool isReverse() const</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00600">VectorUtils.h:600</a></div></div>
<div class="ttc" id="astructllvm_1_1Align_html"><div class="ttname"><a href="structllvm_1_1Align.html">llvm::Align</a></div><div class="ttdoc">This struct is a compact representation of a valid (non-zero power of two) alignment.</div><div class="ttdef"><b>Definition:</b> <a href="Alignment_8h_source.html#l00039">Alignment.h:39</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleaveGroup_html_ab945330dc19d757dfe310145636b370c"><div class="ttname"><a href="classllvm_1_1InterleaveGroup.html#ab945330dc19d757dfe310145636b370c">llvm::InterleaveGroup::getMember</a></div><div class="ttdeci">InstTy * getMember(uint32_t Index) const</div><div class="ttdoc">Get the member with the given index Index.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00655">VectorUtils.h:655</a></div></div>
<div class="ttc" id="anamespacellvm_1_1NVPTX_1_1PTXLdStInstCode_html_a91119cbee2be000c528a690252aee07ca09c68d67f7dbfa6cc77eaf73aa535217"><div class="ttname"><a href="namespacellvm_1_1NVPTX_1_1PTXLdStInstCode.html#a91119cbee2be000c528a690252aee07ca09c68d67f7dbfa6cc77eaf73aa535217">llvm::NVPTX::PTXLdStInstCode::Scalar</a></div><div class="ttdeci">@ Scalar</div><div class="ttdef"><b>Definition:</b> <a href="NVPTX_8h_source.html#l00122">NVPTX.h:122</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleavedAccessInfo_html_a3a6e7f9f2e6125cd856a51aefc741091"><div class="ttname"><a href="classllvm_1_1InterleavedAccessInfo.html#a3a6e7f9f2e6125cd856a51aefc741091">llvm::InterleavedAccessInfo::getInterleaveGroups</a></div><div class="ttdeci">iterator_range&lt; SmallPtrSetIterator&lt; llvm::InterleaveGroup&lt; Instruction &gt; * &gt; &gt; getInterleaveGroups()</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00779">VectorUtils.h:779</a></div></div>
<div class="ttc" id="aclassllvm_1_1LinearPolySize_html_afaf8f62538ab335bb4e3e08a1a57e27f"><div class="ttname"><a href="classllvm_1_1LinearPolySize.html#afaf8f62538ab335bb4e3e08a1a57e27f">llvm::LinearPolySize&lt; ElementCount &gt;::getFixed</a></div><div class="ttdeci">static ElementCount getFixed(ScalarTy MinVal)</div><div class="ttdef"><b>Definition:</b> <a href="TypeSize_8h_source.html#l00284">TypeSize.h:284</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleavedAccessInfo_html_a7697f9f41ff04e918857f5af7c36fc2a"><div class="ttname"><a href="classllvm_1_1InterleavedAccessInfo.html#a7697f9f41ff04e918857f5af7c36fc2a">llvm::InterleavedAccessInfo::isInterleaved</a></div><div class="ttdeci">bool isInterleaved(Instruction *Instr) const</div><div class="ttdoc">Check if Instr belongs to any interleave group.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00766">VectorUtils.h:766</a></div></div>
<div class="ttc" id="anamespacellvm_html_a277fb9dbf4fa0638e214ac4777544e83"><div class="ttname"><a href="namespacellvm.html#a277fb9dbf4fa0638e214ac4777544e83">llvm::checkedAdd</a></div><div class="ttdeci">std::enable_if_t&lt; std::is_signed&lt; T &gt;::value, llvm::Optional&lt; T &gt; &gt; checkedAdd(T LHS, T RHS)</div><div class="ttdoc">Add two signed integers LHS and RHS.</div><div class="ttdef"><b>Definition:</b> <a href="CheckedArithmetic_8h_source.html#l00048">CheckedArithmetic.h:48</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleaveGroup_html_a722a0e30a844c1f562b38ca7e06d6213"><div class="ttname"><a href="classllvm_1_1InterleaveGroup.html#a722a0e30a844c1f562b38ca7e06d6213">llvm::InterleaveGroup::setInsertPos</a></div><div class="ttdeci">void setInsertPos(InstTy *Inst)</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00672">VectorUtils.h:672</a></div></div>
<div class="ttc" id="astructllvm_1_1VFParameter_html"><div class="ttname"><a href="structllvm_1_1VFParameter.html">llvm::VFParameter</a></div><div class="ttdoc">Encapsulates information needed to describe a parameter.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00062">VectorUtils.h:62</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleaveGroup_html_aac206f570f599e8832d28a15bddb12d5"><div class="ttname"><a href="classllvm_1_1InterleaveGroup.html#aac206f570f599e8832d28a15bddb12d5">llvm::InterleaveGroup::getInsertPos</a></div><div class="ttdeci">InstTy * getInsertPos() const</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00671">VectorUtils.h:671</a></div></div>
<div class="ttc" id="astructllvm_1_1VFParameter_html_a55f4f41d21dba4ac5064e0b93224a4bf"><div class="ttname"><a href="structllvm_1_1VFParameter.html#a55f4f41d21dba4ac5064e0b93224a4bf">llvm::VFParameter::LinearStepOrPos</a></div><div class="ttdeci">int LinearStepOrPos</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00065">VectorUtils.h:65</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleaveGroup_html_a5bb08a7480808cec4d5b9e1d0a3012c6"><div class="ttname"><a href="classllvm_1_1InterleaveGroup.html#a5bb08a7480808cec4d5b9e1d0a3012c6">llvm::InterleaveGroup::getIndex</a></div><div class="ttdeci">uint32_t getIndex(const InstTy *Instr) const</div><div class="ttdoc">Get the index for the given member.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00662">VectorUtils.h:662</a></div></div>
<div class="ttc" id="aclassllvm_1_1SCEV_html"><div class="ttname"><a href="classllvm_1_1SCEV.html">llvm::SCEV</a></div><div class="ttdoc">This class represents an analyzed expression in the program.</div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8h_source.html#l00078">ScalarEvolution.h:78</a></div></div>
<div class="ttc" id="anamespacellvm_html_abff3996076b4c76ea19757dc6853436e"><div class="ttname"><a href="namespacellvm.html#abff3996076b4c76ea19757dc6853436e">llvm::hasVectorInstrinsicOverloadedScalarOpd</a></div><div class="ttdeci">bool hasVectorInstrinsicOverloadedScalarOpd(Intrinsic::ID ID, unsigned ScalarOpdIdx)</div><div class="ttdoc">Identifies if the vector form of the intrinsic has a scalar operand that has an overloaded type.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00117">VectorUtils.cpp:117</a></div></div>
<div class="ttc" id="aELFObjHandler_8cpp_html_aef61945034b9431b804748fc317c5548"><div class="ttname"><a href="ELFObjHandler_8cpp.html#aef61945034b9431b804748fc317c5548">Index</a></div><div class="ttdeci">uint32_t Index</div><div class="ttdef"><b>Definition:</b> <a href="ELFObjHandler_8cpp_source.html#l00084">ELFObjHandler.cpp:84</a></div></div>
<div class="ttc" id="aclassllvm_1_1VFDatabase_html_af9abb14ef675e9dee8dd14bd4dd43aac"><div class="ttname"><a href="classllvm_1_1VFDatabase.html#af9abb14ef675e9dee8dd14bd4dd43aac">llvm::VFDatabase::getMappings</a></div><div class="ttdeci">static SmallVector&lt; VFInfo, 8 &gt; getMappings(const CallInst &amp;CI)</div><div class="ttdoc">Retrieve all the VFInfo instances associated to the CallInst CI.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00249">VectorUtils.h:249</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleaveGroup_html_a46f3b431a3121fdf53608a283bf4efec"><div class="ttname"><a href="classllvm_1_1InterleaveGroup.html#a46f3b431a3121fdf53608a283bf4efec">llvm::InterleaveGroup::getFactor</a></div><div class="ttdeci">uint32_t getFactor() const</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00601">VectorUtils.h:601</a></div></div>
<div class="ttc" id="astructllvm_1_1VFInfo_html_aa8ab6db11ae7c0891185e2a2a1f338d5"><div class="ttname"><a href="structllvm_1_1VFInfo.html#aa8ab6db11ae7c0891185e2a2a1f338d5">llvm::VFInfo::ISA</a></div><div class="ttdeci">VFISAKind ISA</div><div class="ttdoc">Vector Function Name associated to this VFInfo.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00127">VectorUtils.h:127</a></div></div>
<div class="ttc" id="agroup__VFDatabase_html_ga66862f50dead385e61e416b35110c5f1"><div class="ttname"><a href="group__VFDatabase.html#ga66862f50dead385e61e416b35110c5f1">llvm::VFDatabase::getVectorizedFunction</a></div><div class="ttdeci">Function * getVectorizedFunction(const VFShape &amp;Shape) const</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00268">VectorUtils.h:268</a></div></div>
<div class="ttc" id="aclassllvm_1_1DenseMap_html"><div class="ttname"><a href="classllvm_1_1DenseMap.html">llvm::DenseMap&lt; int32_t, InstTy * &gt;</a></div></div>
<div class="ttc" id="aMD5_8cpp_html_ac0eafdc9ee161b71e7af98af736952fd"><div class="ttname"><a href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a></div><div class="ttdeci">#define I(x, y, z)</div><div class="ttdef"><b>Definition:</b> <a href="MD5_8cpp_source.html#l00059">MD5.cpp:59</a></div></div>
<div class="ttc" id="anamespacellvm_html_ae3bea22b27151dae0f6e4a00f71cf857"><div class="ttname"><a href="namespacellvm.html#ae3bea22b27151dae0f6e4a00f71cf857">llvm::hasVectorInstrinsicScalarOpd</a></div><div class="ttdeci">bool hasVectorInstrinsicScalarOpd(Intrinsic::ID ID, unsigned ScalarOpdIdx)</div><div class="ttdoc">Identifies if the vector form of the intrinsic has a scalar operand.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00099">VectorUtils.cpp:99</a></div></div>
<div class="ttc" id="aclassllvm_1_1LoopAccessInfo_html"><div class="ttname"><a href="classllvm_1_1LoopAccessInfo.html">llvm::LoopAccessInfo</a></div><div class="ttdoc">Drive the analysis of memory accesses in the loop.</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00525">LoopAccessAnalysis.h:525</a></div></div>
<div class="ttc" id="anamespacellvm_html_a4288169d91ab0f0f01405115fd2931a7"><div class="ttname"><a href="namespacellvm.html#a4288169d91ab0f0f01405115fd2931a7">llvm::concatenateVectors</a></div><div class="ttdeci">Value * concatenateVectors(IRBuilderBase &amp;Builder, ArrayRef&lt; Value * &gt; Vecs)</div><div class="ttdoc">Concatenate a list of vectors.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00852">VectorUtils.cpp:852</a></div></div>
<div class="ttc" id="aclassllvm_1_1DenseMapBase_html_a0c047f127ed4380a6f383d70bec4eb94"><div class="ttname"><a href="classllvm_1_1DenseMapBase.html#a0c047f127ed4380a6f383d70bec4eb94">llvm::DenseMapBase::find</a></div><div class="ttdeci">iterator find(const_arg_type_t&lt; KeyT &gt; Val)</div><div class="ttdef"><b>Definition:</b> <a href="DenseMap_8h_source.html#l00150">DenseMap.h:150</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleavedAccessInfo_html_af587d7218fa15a456103c3d2125a1fc8"><div class="ttname"><a href="classllvm_1_1InterleavedAccessInfo.html#af587d7218fa15a456103c3d2125a1fc8">llvm::InterleavedAccessInfo::analyzeInterleaving</a></div><div class="ttdeci">void analyzeInterleaving(bool EnableMaskedInterleavedGroup)</div><div class="ttdoc">Analyze the interleaved accesses and collect them in interleave groups.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l01029">VectorUtils.cpp:1029</a></div></div>
<div class="ttc" id="aSILowerControlFlow_8cpp_html_a4868c5d81c5ccc98c47aeab6244346a0"><div class="ttname"><a href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a></div><div class="ttdeci">assert(ImpDefSCC.getReg()==AMDGPU::SCC &amp;&amp;ImpDefSCC.isDef())</div></div>
<div class="ttc" id="allvm_2Support_2ErrorHandling_8h_html_ace243f5c25697a1107cce46626b3dc94"><div class="ttname"><a href="llvm_2Support_2ErrorHandling_8h.html#ace243f5c25697a1107cce46626b3dc94">llvm_unreachable</a></div><div class="ttdeci">#define llvm_unreachable(msg)</div><div class="ttdoc">Marks that the current location is not supposed to be reachable.</div><div class="ttdef"><b>Definition:</b> <a href="llvm_2Support_2ErrorHandling_8h_source.html#l00136">ErrorHandling.h:136</a></div></div>
<div class="ttc" id="anamespacellvm_1_1ISD_html_a22ea9cec080dd5f4f47ba234c2f59110a8472e46f9e4db168c5610ecdfb05dbaf"><div class="ttname"><a href="namespacellvm_1_1ISD.html#a22ea9cec080dd5f4f47ba234c2f59110a8472e46f9e4db168c5610ecdfb05dbaf">llvm::ISD::BasicBlock</a></div><div class="ttdeci">@ BasicBlock</div><div class="ttdoc">Various leaf nodes.</div><div class="ttdef"><b>Definition:</b> <a href="ISDOpcodes_8h_source.html#l00071">ISDOpcodes.h:71</a></div></div>
<div class="ttc" id="anamespacellvm_html_aa0d69e81725c10fa5407f0bf34462068"><div class="ttname"><a href="namespacellvm.html#aa0d69e81725c10fa5407f0bf34462068">llvm::TTI</a></div><div class="ttdeci">TargetTransformInfo TTI</div><div class="ttdef"><b>Definition:</b> <a href="TargetTransformInfo_8h_source.html#l00163">TargetTransformInfo.h:162</a></div></div>
<div class="ttc" id="aclassllvm_1_1Module_html"><div class="ttname"><a href="classllvm_1_1Module.html">llvm::Module</a></div><div class="ttdoc">A Module instance is used to store all the information related to an LLVM module.</div><div class="ttdef"><b>Definition:</b> <a href="Module_8h_source.html#l00067">Module.h:67</a></div></div>
<div class="ttc" id="anamespacellvm_html_a673cf7e3d4e84d3e3dfa9dc000499cba"><div class="ttname"><a href="namespacellvm.html#a673cf7e3d4e84d3e3dfa9dc000499cba">llvm::createBitMaskForGaps</a></div><div class="ttdeci">Constant * createBitMaskForGaps(IRBuilderBase &amp;Builder, unsigned VF, const InterleaveGroup&lt; Instruction &gt; &amp;Group)</div><div class="ttdoc">Create a mask that filters the members of an interleave group where there are gaps.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00766">VectorUtils.cpp:766</a></div></div>
<div class="ttc" id="astructllvm_1_1VFInfo_html_abfb66d9c1a71777713734b160cc4f0b5"><div class="ttname"><a href="structllvm_1_1VFInfo.html#abfb66d9c1a71777713734b160cc4f0b5">llvm::VFInfo::ScalarName</a></div><div class="ttdeci">std::string ScalarName</div><div class="ttdoc">Classification of the vector function.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00125">VectorUtils.h:125</a></div></div>
<div class="ttc" id="aAssumeBundleBuilder_8cpp_html_afb136e0532bcaed86521b462e6538d62"><div class="ttname"><a href="AssumeBundleBuilder_8cpp.html#afb136e0532bcaed86521b462e6538d62">Builder</a></div><div class="ttdeci">assume Assume Builder</div><div class="ttdef"><b>Definition:</b> <a href="AssumeBundleBuilder_8cpp_source.html#l00651">AssumeBundleBuilder.cpp:651</a></div></div>
<div class="ttc" id="astructllvm_1_1VFShape_html_aea3cb55414569157978afce988b13659"><div class="ttname"><a href="structllvm_1_1VFShape.html#aea3cb55414569157978afce988b13659">llvm::VFShape::operator==</a></div><div class="ttdeci">bool operator==(const VFShape &amp;Other) const</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00086">VectorUtils.h:86</a></div></div>
<div class="ttc" id="aclassllvm_1_1LoopAccessInfo_html_acbe724e001e95a061672be1975932c0b"><div class="ttname"><a href="classllvm_1_1LoopAccessInfo.html#acbe724e001e95a061672be1975932c0b">llvm::LoopAccessInfo::getDepChecker</a></div><div class="ttdeci">const MemoryDepChecker &amp; getDepChecker() const</div><div class="ttdoc">the Memory Dependence Checker which can determine the loop-independent and loop-carried dependences b...</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00567">LoopAccessAnalysis.h:567</a></div></div>
<div class="ttc" id="anamespacellvm_html_a51d22a1ed809d7cb1c1eb46c820c8226"><div class="ttname"><a href="namespacellvm.html#a51d22a1ed809d7cb1c1eb46c820c8226">llvm::intersectAccessGroups</a></div><div class="ttdeci">MDNode * intersectAccessGroups(const Instruction *Inst1, const Instruction *Inst2)</div><div class="ttdoc">Compute the access-group list of access groups that Inst1 and Inst2 are both in.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00673">VectorUtils.cpp:673</a></div></div>
<div class="ttc" id="aclassllvm_1_1LoopInfo_html"><div class="ttname"><a href="classllvm_1_1LoopInfo.html">llvm::LoopInfo</a></div><div class="ttdef"><b>Definition:</b> <a href="LoopInfo_8h_source.html#l01083">LoopInfo.h:1083</a></div></div>
<div class="ttc" id="anamespacellvm_html_add480f2ed87faa59c16d4c01ffb4bf39a88183b946cc5f0e8c96b2e66e1c74a7e"><div class="ttname"><a href="namespacellvm.html#add480f2ed87faa59c16d4c01ffb4bf39a88183b946cc5f0e8c96b2e66e1c74a7e">llvm::VFParamKind::Unknown</a></div><div class="ttdeci">@ Unknown</div></div>
<div class="ttc" id="anamespacellvm_html_a57f2ca0e57f4f7b13f56f9aa16af3e0d"><div class="ttname"><a href="namespacellvm.html#a57f2ca0e57f4f7b13f56f9aa16af3e0d">llvm::min</a></div><div class="ttdeci">Expected&lt; ExpressionValue &gt; min(const ExpressionValue &amp;Lhs, const ExpressionValue &amp;Rhs)</div><div class="ttdef"><b>Definition:</b> <a href="FileCheck_8cpp_source.html#l00357">FileCheck.cpp:357</a></div></div>
<div class="ttc" id="aclassllvm_1_1StringRef_html"><div class="ttname"><a href="classllvm_1_1StringRef.html">llvm::StringRef</a></div><div class="ttdoc">StringRef - Represent a constant reference to a string, i.e.</div><div class="ttdef"><b>Definition:</b> <a href="StringRef_8h_source.html#l00058">StringRef.h:58</a></div></div>
<div class="ttc" id="anamespacellvm_1_1cl_html_ac96f30ba8b117dbd380b88ab8a03732ba1e82b710efc2f25cc275e53b3833e6fa"><div class="ttname"><a href="namespacellvm_1_1cl.html#ac96f30ba8b117dbd380b88ab8a03732ba1e82b710efc2f25cc275e53b3833e6fa">llvm::cl::Sink</a></div><div class="ttdeci">@ Sink</div><div class="ttdef"><b>Definition:</b> <a href="CommandLine_8h_source.html#l00171">CommandLine.h:171</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a015846b6188ce15e08cd94c74a9df1a3"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a015846b6188ce15e08cd94c74a9df1a3">A</a></div><div class="ttdeci">* A</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00089">README_ALTIVEC.txt:89</a></div></div>
<div class="ttc" id="aclassuint32__t_html"><div class="ttname"><a href="classuint32__t.html">uint32_t</a></div></div>
<div class="ttc" id="aclassllvm_1_1Value_html_adb5c319f5905c1d3ca9eb5df546388c5"><div class="ttname"><a href="classllvm_1_1Value.html#adb5c319f5905c1d3ca9eb5df546388c5">llvm::Value::getName</a></div><div class="ttdeci">StringRef getName() const</div><div class="ttdoc">Return a constant reference to the value's name.</div><div class="ttdef"><b>Definition:</b> <a href="Value_8cpp_source.html#l00297">Value.cpp:297</a></div></div>
<div class="ttc" id="aclassllvm_1_1DenseMapBase_html_a99f811d53704275b4158c62a2dd138d9"><div class="ttname"><a href="classllvm_1_1DenseMapBase.html#a99f811d53704275b4158c62a2dd138d9">llvm::DenseMapBase&lt; DenseMap&lt; KeyT, ValueT, DenseMapInfo&lt; KeyT &gt;, llvm::detail::DenseMapPair&lt; KeyT, ValueT &gt; &gt;, KeyT, ValueT, DenseMapInfo&lt; KeyT &gt;, llvm::detail::DenseMapPair&lt; KeyT, ValueT &gt; &gt;::insert</a></div><div class="ttdeci">std::pair&lt; iterator, bool &gt; insert(const std::pair&lt; KeyT, ValueT &gt; &amp;KV)</div><div class="ttdef"><b>Definition:</b> <a href="DenseMap_8h_source.html#l00207">DenseMap.h:207</a></div></div>
<div class="ttc" id="anamespacellvm_html_a7504dd988bee776d391c05231515297d"><div class="ttname"><a href="namespacellvm.html#a7504dd988bee776d391c05231515297d">llvm::createReplicatedMask</a></div><div class="ttdeci">llvm::SmallVector&lt; int, 16 &gt; createReplicatedMask(unsigned ReplicationFactor, unsigned VF)</div><div class="ttdoc">Create a mask with replicated elements.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00786">VectorUtils.cpp:786</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleaveGroup_html_a3c0ed6567fafd374da72087409959b75"><div class="ttname"><a href="classllvm_1_1InterleaveGroup.html#a3c0ed6567fafd374da72087409959b75">llvm::InterleaveGroup::requiresScalarEpilogue</a></div><div class="ttdeci">bool requiresScalarEpilogue() const</div><div class="ttdoc">Returns true if this Group requires a scalar iteration to handle gaps.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00683">VectorUtils.h:683</a></div></div>
<div class="ttc" id="anamespacellvm_1_1VFABI_html_aaf19acac548dca3c8f263ceb6a860b57"><div class="ttname"><a href="namespacellvm_1_1VFABI.html#aaf19acac548dca3c8f263ceb6a860b57">llvm::VFABI::getVFParamKindFromString</a></div><div class="ttdeci">VFParamKind getVFParamKindFromString(const StringRef Token)</div><div class="ttdoc">Retrieve the VFParamKind from a string token.</div><div class="ttdef"><b>Definition:</b> <a href="VFABIDemangling_8cpp_source.html#l00461">VFABIDemangling.cpp:461</a></div></div>
<div class="ttc" id="anamespacellvm_html_a4373d3025961c2c2eeca56b02d7d009d"><div class="ttname"><a href="namespacellvm.html#a4373d3025961c2c2eeca56b02d7d009d">llvm::widenShuffleMaskElts</a></div><div class="ttdeci">bool widenShuffleMaskElts(int Scale, ArrayRef&lt; int &gt; Mask, SmallVectorImpl&lt; int &gt; &amp;ScaledMask)</div><div class="ttdoc">Try to transform a shuffle mask by replacing elements with the scaled index for an equivalent mask of...</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00442">VectorUtils.cpp:442</a></div></div>
<div class="ttc" id="astructllvm_1_1VFShape_html_a77688fcf1805363e5914276b0d491b63"><div class="ttname"><a href="structllvm_1_1VFShape.html#a77688fcf1805363e5914276b0d491b63">llvm::VFShape::VF</a></div><div class="ttdeci">ElementCount VF</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00083">VectorUtils.h:83</a></div></div>
<div class="ttc" id="aclassllvm_1_1DenseMapBase_html_a65520b9c67759099e313d0f4e7b5ff9e"><div class="ttname"><a href="classllvm_1_1DenseMapBase.html#a65520b9c67759099e313d0f4e7b5ff9e">llvm::DenseMapBase::end</a></div><div class="ttdeci">iterator end()</div><div class="ttdef"><b>Definition:</b> <a href="DenseMap_8h_source.html#l00083">DenseMap.h:83</a></div></div>
<div class="ttc" id="aclassllvm_1_1CallBase_html_adde2ea00dd2613ee41bfe91908e4e68e"><div class="ttname"><a href="classllvm_1_1CallBase.html#adde2ea00dd2613ee41bfe91908e4e68e">llvm::CallBase::arg_size</a></div><div class="ttdeci">unsigned arg_size() const</div><div class="ttdef"><b>Definition:</b> <a href="InstrTypes_8h_source.html#l01326">InstrTypes.h:1326</a></div></div>
<div class="ttc" id="astructllvm_1_1VFShape_html_a7ac579f061e62acfe262be1d1906eea2"><div class="ttname"><a href="structllvm_1_1VFShape.html#a7ac579f061e62acfe262be1d1906eea2">llvm::VFShape::updateParam</a></div><div class="ttdeci">void updateParam(VFParameter P)</div><div class="ttdoc">Update the parameter in position P.ParamPos to P.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00091">VectorUtils.h:91</a></div></div>
<div class="ttc" id="aclassllvm_1_1DenseMapBase_html_a3d95cc2d359b8d9ed5bd9504b44930b5"><div class="ttname"><a href="classllvm_1_1DenseMapBase.html#a3d95cc2d359b8d9ed5bd9504b44930b5">llvm::DenseMapBase::size</a></div><div class="ttdeci">unsigned size() const</div><div class="ttdef"><b>Definition:</b> <a href="DenseMap_8h_source.html#l00100">DenseMap.h:100</a></div></div>
<div class="ttc" id="anamespacellvm_1_1TargetStackID_html_a71392100eb15ba746b1f898986f5d8a5"><div class="ttname"><a href="namespacellvm_1_1TargetStackID.html#a71392100eb15ba746b1f898986f5d8a5">llvm::TargetStackID::Value</a></div><div class="ttdeci">Value</div><div class="ttdef"><b>Definition:</b> <a href="TargetFrameLowering_8h_source.html#l00027">TargetFrameLowering.h:27</a></div></div>
<div class="ttc" id="anamespacellvm_html_ab09fc7dee4f7e02c60f7a9c928dc1603"><div class="ttname"><a href="namespacellvm.html#ab09fc7dee4f7e02c60f7a9c928dc1603">llvm::findScalarElement</a></div><div class="ttdeci">Value * findScalarElement(Value *V, unsigned EltNo)</div><div class="ttdoc">Given a vector and an element number, see if the scalar value is already around as a register,...</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00280">VectorUtils.cpp:280</a></div></div>
<div class="ttc" id="anamespacellvm_1_1VFABI_html_a3b4aafd885099e61903f0a29e638a8b1"><div class="ttname"><a href="namespacellvm_1_1VFABI.html#a3b4aafd885099e61903f0a29e638a8b1">llvm::VFABI::_LLVM_Scalarize_</a></div><div class="ttdeci">static constexpr char const  * _LLVM_Scalarize_</div><div class="ttdoc">Prefix for internal name redirection for vector function that tells the compiler to scalarize the cal...</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00139">VectorUtils.h:139</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleavedAccessInfo_html_a34ed64ff27fabc002da4047589142b02"><div class="ttname"><a href="classllvm_1_1InterleavedAccessInfo.html#a34ed64ff27fabc002da4047589142b02">llvm::InterleavedAccessInfo::requiresScalarEpilogue</a></div><div class="ttdeci">bool requiresScalarEpilogue() const</div><div class="ttdoc">Returns true if an interleaved group that may access memory out-of-bounds requires a scalar epilogue ...</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00785">VectorUtils.h:785</a></div></div>
<div class="ttc" id="anamespacellvm_html_afe8a7cc03eb7adf81589f0744e379f74"><div class="ttname"><a href="namespacellvm.html#afe8a7cc03eb7adf81589f0744e379f74">llvm::getSplatIndex</a></div><div class="ttdeci">int getSplatIndex(ArrayRef&lt; int &gt; Mask)</div><div class="ttdoc">If all non-negative Mask elements are the same value, return that value.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00338">VectorUtils.cpp:338</a></div></div>
<div class="ttc" id="aSmallVector_8h_html"><div class="ttname"><a href="SmallVector_8h.html">SmallVector.h</a></div></div>
<div class="ttc" id="anamespacellvm_html_a0bab12864bbc1f177e0999b0706bbcbb"><div class="ttname"><a href="namespacellvm.html#a0bab12864bbc1f177e0999b0706bbcbb">llvm::stripGetElementPtr</a></div><div class="ttdeci">Value * stripGetElementPtr(Value *Ptr, ScalarEvolution *SE, Loop *Lp)</div><div class="ttdoc">If the argument is a GEP, then returns the operand identified by getGEPInductionOperand.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00171">VectorUtils.cpp:171</a></div></div>
<div class="ttc" id="astructllvm_1_1VFShape_html_a33df83a8555fc8dd7c7d547576abb354"><div class="ttname"><a href="structllvm_1_1VFShape.html#a33df83a8555fc8dd7c7d547576abb354">llvm::VFShape::get</a></div><div class="ttdeci">static VFShape get(const CallInst &amp;CI, ElementCount EC, bool HasGlobalPred)</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00108">VectorUtils.h:108</a></div></div>
<div class="ttc" id="aclassllvm_1_1iterator__range_html"><div class="ttname"><a href="classllvm_1_1iterator__range.html">llvm::iterator_range</a></div><div class="ttdoc">A range adaptor for a pair of iterators.</div><div class="ttdef"><b>Definition:</b> <a href="iterator__range_8h_source.html#l00030">iterator_range.h:30</a></div></div>
<div class="ttc" id="aRelocation_8txt_html_ad0265f082d0dc86496888b7cec1b717d"><div class="ttname"><a href="Relocation_8txt.html#ad0265f082d0dc86496888b7cec1b717d">LLVM</a></div><div class="ttdeci">MIPS Relocation Principles In LLVM</div><div class="ttdef"><b>Definition:</b> <a href="Relocation_8txt_source.html#l00003">Relocation.txt:3</a></div></div>
<div class="ttc" id="aclassllvm_1_1SmallVectorImpl_html"><div class="ttname"><a href="classllvm_1_1SmallVectorImpl.html">llvm::SmallVectorImpl&lt; std::string &gt;</a></div></div>
<div class="ttc" id="anamespacellvm_1_1VFABI_html_a8f5eee7fb0b7a37cb4e8d68e2d1c1fe6"><div class="ttname"><a href="namespacellvm_1_1VFABI.html#a8f5eee7fb0b7a37cb4e8d68e2d1c1fe6">llvm::VFABI::tryDemangleForVFABI</a></div><div class="ttdeci">Optional&lt; VFInfo &gt; tryDemangleForVFABI(StringRef MangledName, const Module &amp;M)</div><div class="ttdoc">Function to construct a VFInfo out of a mangled names in the following format:</div><div class="ttdef"><b>Definition:</b> <a href="VFABIDemangling_8cpp_source.html#l00319">VFABIDemangling.cpp:319</a></div></div>
<div class="ttc" id="anamespacellvm_1_1msgpack_html_afdae9da66bac09f4b2bfc0fd9f0559e6"><div class="ttname"><a href="namespacellvm_1_1msgpack.html#afdae9da66bac09f4b2bfc0fd9f0559e6">llvm::msgpack::Type</a></div><div class="ttdeci">Type</div><div class="ttdoc">MessagePack types as defined in the standard, with the exception of Integer being divided into a sign...</div><div class="ttdef"><b>Definition:</b> <a href="MsgPackReader_8h_source.html#l00049">MsgPackReader.h:49</a></div></div>
<div class="ttc" id="anamespacellvm_html_a689f785bfa4f3650dc44d519df0406fd"><div class="ttname"><a href="namespacellvm.html#a689f785bfa4f3650dc44d519df0406fd">llvm::createStrideMask</a></div><div class="ttdeci">llvm::SmallVector&lt; int, 16 &gt; createStrideMask(unsigned Start, unsigned Stride, unsigned VF)</div><div class="ttdoc">Create a stride shuffle mask.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00806">VectorUtils.cpp:806</a></div></div>
<div class="ttc" id="aclassllvm_1_1CallInst_html"><div class="ttname"><a href="classllvm_1_1CallInst.html">llvm::CallInst</a></div><div class="ttdoc">This class represents a function call, abstracting a target machine's calling convention.</div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l01475">Instructions.h:1475</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a09776db24cf586ec9f1e18f3bae14099"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a09776db24cf586ec9f1e18f3bae14099">BB</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM BB</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00039">README.txt:39</a></div></div>
<div class="ttc" id="anamespacellvm_html_af00a6f39da9d94ec387a366ade60aea5"><div class="ttname"><a href="namespacellvm.html#af00a6f39da9d94ec387a366ade60aea5">llvm::createSequentialMask</a></div><div class="ttdeci">llvm::SmallVector&lt; int, 16 &gt; createSequentialMask(unsigned Start, unsigned NumInts, unsigned NumUndefs)</div><div class="ttdoc">Create a sequential shuffle mask.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00814">VectorUtils.cpp:814</a></div></div>
<div class="ttc" id="anamespacellvm_html_abe2c24a8dc2fb979e8e54e15f088169ca4863502abea45861b9ed022e66d66cb2"><div class="ttname"><a href="namespacellvm.html#abe2c24a8dc2fb979e8e54e15f088169ca4863502abea45861b9ed022e66d66cb2">llvm::VFISAKind::AVX</a></div><div class="ttdeci">@ AVX</div></div>
<div class="ttc" id="aclassllvm_1_1InterleavedAccessInfo_html_a9d9b6620a692f452f5080cb0c20e41e3"><div class="ttname"><a href="classllvm_1_1InterleavedAccessInfo.html#a9d9b6620a692f452f5080cb0c20e41e3">llvm::InterleavedAccessInfo::invalidateGroups</a></div><div class="ttdeci">bool invalidateGroups()</div><div class="ttdoc">Invalidate groups, e.g., in case all blocks in loop will be predicated contrary to original assumptio...</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00749">VectorUtils.h:749</a></div></div>
<div class="ttc" id="anamespacellvm_html_a2816e84a08c108d18bc4665bc1817e01"><div class="ttname"><a href="namespacellvm.html#a2816e84a08c108d18bc4665bc1817e01">llvm::abs</a></div><div class="ttdeci">APFloat abs(APFloat X)</div><div class="ttdoc">Returns the absolute value of the argument.</div><div class="ttdef"><b>Definition:</b> <a href="APFloat_8h_source.html#l01284">APFloat.h:1284</a></div></div>
<div class="ttc" id="aclassllvm_1_1VectorType_html_a8c90e6c50e795b17466482a04947690e"><div class="ttname"><a href="classllvm_1_1VectorType.html#a8c90e6c50e795b17466482a04947690e">llvm::VectorType::get</a></div><div class="ttdeci">static VectorType * get(Type *ElementType, ElementCount EC)</div><div class="ttdoc">This static method is the primary way to construct an VectorType.</div><div class="ttdef"><b>Definition:</b> <a href="Type_8cpp_source.html#l00634">Type.cpp:634</a></div></div>
<div class="ttc" id="aclassllvm_1_1VFDatabase_html_a3881ccac8348749253e8d558a829cd21"><div class="ttname"><a href="classllvm_1_1VFDatabase.html#a3881ccac8348749253e8d558a829cd21">llvm::VFDatabase::VFDatabase</a></div><div class="ttdeci">VFDatabase(CallInst &amp;CI)</div><div class="ttdoc">Constructor, requires a CallInst instance.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00261">VectorUtils.h:261</a></div></div>
<div class="ttc" id="aclassllvm_1_1Optional_html_a9ed8669536d806aff028d983595bab4d"><div class="ttname"><a href="classllvm_1_1Optional.html#a9ed8669536d806aff028d983595bab4d">llvm::Optional::getValue</a></div><div class="ttdeci">constexpr const T &amp; getValue() const LLVM_LVALUE_FUNCTION</div><div class="ttdef"><b>Definition:</b> <a href="Optional_8h_source.html#l00282">Optional.h:282</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleaveGroup_html_af81c826ee51addc3321e4ef1c1934696"><div class="ttname"><a href="classllvm_1_1InterleaveGroup.html#af81c826ee51addc3321e4ef1c1934696">llvm::InterleaveGroup::getNumMembers</a></div><div class="ttdeci">uint32_t getNumMembers() const</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00603">VectorUtils.h:603</a></div></div>
<div class="ttc" id="aELFYAML_8cpp_html_a2a91b094e777dacc21de2a7f35da6805"><div class="ttname"><a href="ELFYAML_8cpp.html#a2a91b094e777dacc21de2a7f35da6805">Other</a></div><div class="ttdeci">Optional&lt; std::vector&lt; StOtherPiece &gt; &gt; Other</div><div class="ttdef"><b>Definition:</b> <a href="ELFYAML_8cpp_source.html#l01172">ELFYAML.cpp:1172</a></div></div>
<div class="ttc" id="aclassllvm_1_1SmallPtrSetImpl_html_a6bc6fb89fe2e91c25559a8631f56e27e"><div class="ttname"><a href="classllvm_1_1SmallPtrSetImpl.html#a6bc6fb89fe2e91c25559a8631f56e27e">llvm::SmallPtrSetImpl::insert</a></div><div class="ttdeci">std::pair&lt; iterator, bool &gt; insert(PtrType Ptr)</div><div class="ttdoc">Inserts Ptr if and only if there is no element in the container equal to Ptr.</div><div class="ttdef"><b>Definition:</b> <a href="SmallPtrSet_8h_source.html#l00364">SmallPtrSet.h:364</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleaveGroup_html_a9c748347f137d9e3d6c51833e6882272"><div class="ttname"><a href="classllvm_1_1InterleaveGroup.html#a9c748347f137d9e3d6c51833e6882272">llvm::InterleaveGroup::addMetadata</a></div><div class="ttdeci">void addMetadata(InstTy *NewInst) const</div><div class="ttdoc">Add metadata (e.g.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l01296">VectorUtils.cpp:1296</a></div></div>
<div class="ttc" id="anamespacellvm_1_1Intrinsic_html_a80add6b3b1cdaec560907995127adc16"><div class="ttname"><a href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">llvm::Intrinsic::ID</a></div><div class="ttdeci">unsigned ID</div><div class="ttdef"><b>Definition:</b> <a href="TargetTransformInfo_8h_source.html#l00038">TargetTransformInfo.h:38</a></div></div>
<div class="ttc" id="astructllvm_1_1VFParameter_html_a7830a41f82d37336f5fe8d9d76638745"><div class="ttname"><a href="structllvm_1_1VFParameter.html#a7830a41f82d37336f5fe8d9d76638745">llvm::VFParameter::operator==</a></div><div class="ttdeci">bool operator==(const VFParameter &amp;Other) const</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00069">VectorUtils.h:69</a></div></div>
<div class="ttc" id="aclassllvm_1_1InterleavedAccessInfo_html_aff4d67798e0101bd9f69dd6de204dcd1"><div class="ttname"><a href="classllvm_1_1InterleavedAccessInfo.html#aff4d67798e0101bd9f69dd6de204dcd1">llvm::InterleavedAccessInfo::getInterleaveGroup</a></div><div class="ttdeci">InterleaveGroup&lt; Instruction &gt; * getInterleaveGroup(const Instruction *Instr) const</div><div class="ttdoc">Get the interleave group that Instr belongs to.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00774">VectorUtils.h:774</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Feb 8 2022 04:20:40 for LLVM by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
