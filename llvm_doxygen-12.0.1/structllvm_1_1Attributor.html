<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: llvm::Attributor Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLVM
   &#160;<span id="projectnumber">12.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacellvm.html">llvm</a></li><li class="navelem"><a class="el" href="structllvm_1_1Attributor.html">Attributor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structllvm_1_1Attributor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">llvm::Attributor Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The fixpoint analysis framework that orchestrates the attribute deduction.  
 <a href="structllvm_1_1Attributor.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="Attributor_8h_source.html">llvm/Transforms/IPO/Attributor.h</a>&quot;</code></p>
<div class="dynheader">
Collaboration diagram for llvm::Attributor:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structllvm_1_1Attributor__coll__graph.svg" width="1290" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor_1_1ArgumentReplacementInfo.html">ArgumentReplacementInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct used in the communication between an abstract attribute (AA) that wants to change the signature of a function and the <a class="el" href="structllvm_1_1Attributor.html" title="The fixpoint analysis framework that orchestrates the attribute deduction.">Attributor</a> which applies the changes.  <a href="structllvm_1_1Attributor_1_1ArgumentReplacementInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a136f42a9aa18c9cda2a4ebeffa1f530e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a136f42a9aa18c9cda2a4ebeffa1f530e">Attributor</a> (<a class="el" href="classllvm_1_1SetVector.html">SetVector</a>&lt; <a class="el" href="classllvm_1_1Function.html">Function</a> * &gt; &amp;Functions, <a class="el" href="structllvm_1_1InformationCache.html">InformationCache</a> &amp;InfoCache, <a class="el" href="classllvm_1_1CallGraphUpdater.html">CallGraphUpdater</a> &amp;CGUpdater, <a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> char * &gt; *Allowed=nullptr)</td></tr>
<tr class="memdesc:a136f42a9aa18c9cda2a4ebeffa1f530e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="structllvm_1_1Attributor.html#a136f42a9aa18c9cda2a4ebeffa1f530e">More...</a><br /></td></tr>
<tr class="separator:a136f42a9aa18c9cda2a4ebeffa1f530e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec7de1b5853de9ecb0a11eb2ac1c8d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a0ec7de1b5853de9ecb0a11eb2ac1c8d1">~Attributor</a> ()</td></tr>
<tr class="separator:a0ec7de1b5853de9ecb0a11eb2ac1c8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d3babc57be041df699846f65d231c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacellvm.html#acd850975ae5042cacb64a9d0ea4715f3">ChangeStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#af7d3babc57be041df699846f65d231c8">run</a> ()</td></tr>
<tr class="memdesc:af7d3babc57be041df699846f65d231c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the analyses until a fixpoint is reached or enforced (timeout).  <a href="structllvm_1_1Attributor.html#af7d3babc57be041df699846f65d231c8">More...</a><br /></td></tr>
<tr class="separator:af7d3babc57be041df699846f65d231c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d51ee51525dec4ed3041a6cadcbb27"><td class="memTemplParams" colspan="2">template&lt;typename AAType &gt; </td></tr>
<tr class="memitem:a48d51ee51525dec4ed3041a6cadcbb27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> AAType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a48d51ee51525dec4ed3041a6cadcbb27">getAAFor</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;QueryingAA, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1IRPosition.html">IRPosition</a> &amp;IRP, <a class="el" href="classbool.html">bool</a> TrackDependence=<a class="el" href="WebAssemblyExceptionInfo_8cpp.html#ade2a0fe2d2d0735c83fdc3ad5be1e1f2">true</a>, <a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a> DepClass=<a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1aebdf9721be38d1fc1cd6db8c737d1be0">DepClassTy::REQUIRED</a>)</td></tr>
<tr class="memdesc:a48d51ee51525dec4ed3041a6cadcbb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup an abstract attribute of type <code>AAType</code> at position <code>IRP</code>.  <a href="structllvm_1_1Attributor.html#a48d51ee51525dec4ed3041a6cadcbb27">More...</a><br /></td></tr>
<tr class="separator:a48d51ee51525dec4ed3041a6cadcbb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc3fc31180e8449aa7ebe02af30f790"><td class="memTemplParams" colspan="2">template&lt;typename AAType &gt; </td></tr>
<tr class="memitem:a7cc3fc31180e8449aa7ebe02af30f790"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> AAType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a7cc3fc31180e8449aa7ebe02af30f790">getAndUpdateAAFor</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;QueryingAA, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1IRPosition.html">IRPosition</a> &amp;IRP, <a class="el" href="classbool.html">bool</a> TrackDependence=<a class="el" href="WebAssemblyExceptionInfo_8cpp.html#ade2a0fe2d2d0735c83fdc3ad5be1e1f2">true</a>, <a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a> DepClass=<a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1aebdf9721be38d1fc1cd6db8c737d1be0">DepClassTy::REQUIRED</a>)</td></tr>
<tr class="memdesc:a7cc3fc31180e8449aa7ebe02af30f790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to getAAFor but the return abstract attribute will be updated (via <code><a class="el" href="structllvm_1_1AbstractAttribute.html#a03972b18e36635ccda4c5a26891f0d25" title="Hook for the Attributor to trigger an update of the internal state.">AbstractAttribute::update</a></code>) even if it is found in the cache.  <a href="structllvm_1_1Attributor.html#a7cc3fc31180e8449aa7ebe02af30f790">More...</a><br /></td></tr>
<tr class="separator:a7cc3fc31180e8449aa7ebe02af30f790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047bd0070c7f82b4d31a020a82a2d719"><td class="memTemplParams" colspan="2">template&lt;typename AAType &gt; </td></tr>
<tr class="memitem:a047bd0070c7f82b4d31a020a82a2d719"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> AAType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a047bd0070c7f82b4d31a020a82a2d719">getOrCreateAAFor</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1IRPosition.html">IRPosition</a> &amp;IRP, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> *QueryingAA=nullptr, <a class="el" href="classbool.html">bool</a> TrackDependence=<a class="el" href="VectorCombine_8cpp.html#a5a5a8a9d8745dc5abc3da0fe95f1ead4">false</a>, <a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a> DepClass=<a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1a7951811e4b085cf68ed3dc3191f36405">DepClassTy::OPTIONAL</a>, <a class="el" href="classbool.html">bool</a> ForceUpdate=<a class="el" href="VectorCombine_8cpp.html#a5a5a8a9d8745dc5abc3da0fe95f1ead4">false</a>)</td></tr>
<tr class="memdesc:a047bd0070c7f82b4d31a020a82a2d719"><td class="mdescLeft">&#160;</td><td class="mdescRight">The version of getAAFor that allows to omit a querying abstract attribute.  <a href="structllvm_1_1Attributor.html#a047bd0070c7f82b4d31a020a82a2d719">More...</a><br /></td></tr>
<tr class="separator:a047bd0070c7f82b4d31a020a82a2d719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba32c0affd7a3a54e207cdd8a58f6949"><td class="memTemplParams" colspan="2">template&lt;typename AAType &gt; </td></tr>
<tr class="memitem:aba32c0affd7a3a54e207cdd8a58f6949"><td class="memTemplItemLeft" align="right" valign="top">AAType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#aba32c0affd7a3a54e207cdd8a58f6949">lookupAAFor</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1IRPosition.html">IRPosition</a> &amp;IRP, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> *QueryingAA=nullptr, <a class="el" href="classbool.html">bool</a> TrackDependence=<a class="el" href="VectorCombine_8cpp.html#a5a5a8a9d8745dc5abc3da0fe95f1ead4">false</a>, <a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a> DepClass=<a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1a7951811e4b085cf68ed3dc3191f36405">DepClassTy::OPTIONAL</a>)</td></tr>
<tr class="memdesc:aba32c0affd7a3a54e207cdd8a58f6949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the attribute of <code>AAType</code> for <code>IRP</code> if existing.  <a href="structllvm_1_1Attributor.html#aba32c0affd7a3a54e207cdd8a58f6949">More...</a><br /></td></tr>
<tr class="separator:aba32c0affd7a3a54e207cdd8a58f6949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cbebd01cb4b697d9f6827de7e5acee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a44cbebd01cb4b697d9f6827de7e5acee">recordDependence</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;FromAA, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;ToAA, <a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a> DepClass)</td></tr>
<tr class="memdesc:a44cbebd01cb4b697d9f6827de7e5acee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly record a dependence from <code>FromAA</code> to <code>ToAA</code>, that is if <code>FromAA</code> changes <code>ToAA</code> should be updated as well.  <a href="structllvm_1_1Attributor.html#a44cbebd01cb4b697d9f6827de7e5acee">More...</a><br /></td></tr>
<tr class="separator:a44cbebd01cb4b697d9f6827de7e5acee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1f0f6801f6b71fbd4e610e8ec1c778"><td class="memTemplParams" colspan="2">template&lt;typename AAType &gt; </td></tr>
<tr class="memitem:abc1f0f6801f6b71fbd4e610e8ec1c778"><td class="memTemplItemLeft" align="right" valign="top">AAType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#abc1f0f6801f6b71fbd4e610e8ec1c778">registerAA</a> (AAType &amp;AA)</td></tr>
<tr class="memdesc:abc1f0f6801f6b71fbd4e610e8ec1c778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduce a new abstract attribute into the fixpoint analysis.  <a href="structllvm_1_1Attributor.html#abc1f0f6801f6b71fbd4e610e8ec1c778">More...</a><br /></td></tr>
<tr class="separator:abc1f0f6801f6b71fbd4e610e8ec1c778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367f5a7c00648f2fdd4eb72f55393d48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structllvm_1_1InformationCache.html">InformationCache</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a367f5a7c00648f2fdd4eb72f55393d48">getInfoCache</a> ()</td></tr>
<tr class="memdesc:a367f5a7c00648f2fdd4eb72f55393d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the internal information cache.  <a href="structllvm_1_1Attributor.html#a367f5a7c00648f2fdd4eb72f55393d48">More...</a><br /></td></tr>
<tr class="separator:a367f5a7c00648f2fdd4eb72f55393d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c57fa54ffac78fa93b5a1d6f9eb4eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a16c57fa54ffac78fa93b5a1d6f9eb4eb">isModulePass</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a16c57fa54ffac78fa93b5a1d6f9eb4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a module pass, false otherwise.  <a href="structllvm_1_1Attributor.html#a16c57fa54ffac78fa93b5a1d6f9eb4eb">More...</a><br /></td></tr>
<tr class="separator:a16c57fa54ffac78fa93b5a1d6f9eb4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3853ed90dd9241284f8bc645e6363ee8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a3853ed90dd9241284f8bc645e6363ee8">isRunOn</a> (<a class="el" href="classllvm_1_1Function.html">Function</a> &amp;Fn) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a3853ed90dd9241284f8bc645e6363ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if we derive attributes for <code>Fn</code>.  <a href="structllvm_1_1Attributor.html#a3853ed90dd9241284f8bc645e6363ee8">More...</a><br /></td></tr>
<tr class="separator:a3853ed90dd9241284f8bc645e6363ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab9b2e1a33cfbe6f0fa6443046dcaf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#adab9b2e1a33cfbe6f0fa6443046dcaf8">identifyDefaultAbstractAttributes</a> (<a class="el" href="classllvm_1_1Function.html">Function</a> &amp;<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>)</td></tr>
<tr class="memdesc:adab9b2e1a33cfbe6f0fa6443046dcaf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine opportunities to derive 'default' attributes in <code>F</code> and create abstract attribute objects for them.  <a href="structllvm_1_1Attributor.html#adab9b2e1a33cfbe6f0fa6443046dcaf8">More...</a><br /></td></tr>
<tr class="separator:adab9b2e1a33cfbe6f0fa6443046dcaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596c00dc88e93bcbe9f9c58b0c1f23bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a596c00dc88e93bcbe9f9c58b0c1f23bb">isFunctionIPOAmendable</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> &amp;<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>)</td></tr>
<tr class="memdesc:a596c00dc88e93bcbe9f9c58b0c1f23bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the function <code>F</code> is IPO amendable.  <a href="structllvm_1_1Attributor.html#a596c00dc88e93bcbe9f9c58b0c1f23bb">More...</a><br /></td></tr>
<tr class="separator:a596c00dc88e93bcbe9f9c58b0c1f23bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad329ad4e840a3849e8cad4d3daed329"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#aad329ad4e840a3849e8cad4d3daed329">markLiveInternalFunction</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> &amp;<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>)</td></tr>
<tr class="memdesc:aad329ad4e840a3849e8cad4d3daed329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the internal function <code>F</code> as live.  <a href="structllvm_1_1Attributor.html#aad329ad4e840a3849e8cad4d3daed329">More...</a><br /></td></tr>
<tr class="separator:aad329ad4e840a3849e8cad4d3daed329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68190a9c3c6a7ba546fa9cf5e75c22fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a68190a9c3c6a7ba546fa9cf5e75c22fa">removeCallSite</a> (<a class="el" href="classllvm_1_1CallInst.html">CallInst</a> *CI)</td></tr>
<tr class="memdesc:a68190a9c3c6a7ba546fa9cf5e75c22fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to remove callsite.  <a href="structllvm_1_1Attributor.html#a68190a9c3c6a7ba546fa9cf5e75c22fa">More...</a><br /></td></tr>
<tr class="separator:a68190a9c3c6a7ba546fa9cf5e75c22fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95df269c34995fb5c2c123b4638a455b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a95df269c34995fb5c2c123b4638a455b">changeUseAfterManifest</a> (<a class="el" href="classllvm_1_1Use.html">Use</a> &amp;U, <a class="el" href="classllvm_1_1Value.html">Value</a> &amp;NV)</td></tr>
<tr class="memdesc:a95df269c34995fb5c2c123b4638a455b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classllvm_1_1Record.html">Record</a> that <code>U</code> is to be replaces with <code>NV</code> after information was manifested.  <a href="structllvm_1_1Attributor.html#a95df269c34995fb5c2c123b4638a455b">More...</a><br /></td></tr>
<tr class="separator:a95df269c34995fb5c2c123b4638a455b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8d03221cc6e2865ca2b6c28471b7e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a8b8d03221cc6e2865ca2b6c28471b7e9">changeValueAfterManifest</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> &amp;V, <a class="el" href="classllvm_1_1Value.html">Value</a> &amp;NV, <a class="el" href="classbool.html">bool</a> ChangeDroppable=<a class="el" href="WebAssemblyExceptionInfo_8cpp.html#ade2a0fe2d2d0735c83fdc3ad5be1e1f2">true</a>)</td></tr>
<tr class="memdesc:a8b8d03221cc6e2865ca2b6c28471b7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to replace all uses of <code>V</code> with <code>NV</code>.  <a href="structllvm_1_1Attributor.html#a8b8d03221cc6e2865ca2b6c28471b7e9">More...</a><br /></td></tr>
<tr class="separator:a8b8d03221cc6e2865ca2b6c28471b7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e35504e47bdac806456a20c5a6ae2aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a6e35504e47bdac806456a20c5a6ae2aa">changeToUnreachableAfterManifest</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</td></tr>
<tr class="memdesc:a6e35504e47bdac806456a20c5a6ae2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classllvm_1_1Record.html">Record</a> that <code>I</code> is to be replaced with <code>unreachable</code> after information was manifested.  <a href="structllvm_1_1Attributor.html#a6e35504e47bdac806456a20c5a6ae2aa">More...</a><br /></td></tr>
<tr class="separator:a6e35504e47bdac806456a20c5a6ae2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7a62e6ac2580f9bc9cbd488d6852a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a1b7a62e6ac2580f9bc9cbd488d6852a2">registerInvokeWithDeadSuccessor</a> (<a class="el" href="classllvm_1_1InvokeInst.html">InvokeInst</a> &amp;II)</td></tr>
<tr class="memdesc:a1b7a62e6ac2580f9bc9cbd488d6852a2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classllvm_1_1Record.html">Record</a> that <code>II</code> has at least one dead successor block.  <a href="structllvm_1_1Attributor.html#a1b7a62e6ac2580f9bc9cbd488d6852a2">More...</a><br /></td></tr>
<tr class="separator:a1b7a62e6ac2580f9bc9cbd488d6852a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac721eb1fd5b7055e86b73192d40516fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#ac721eb1fd5b7055e86b73192d40516fd">deleteAfterManifest</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</td></tr>
<tr class="memdesc:ac721eb1fd5b7055e86b73192d40516fd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classllvm_1_1Record.html">Record</a> that <code>I</code> is deleted after information was manifested.  <a href="structllvm_1_1Attributor.html#ac721eb1fd5b7055e86b73192d40516fd">More...</a><br /></td></tr>
<tr class="separator:ac721eb1fd5b7055e86b73192d40516fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24ef41b2df43a5c5b1fb5742c8d7846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#ad24ef41b2df43a5c5b1fb5742c8d7846">deleteAfterManifest</a> (<a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> &amp;BB)</td></tr>
<tr class="memdesc:ad24ef41b2df43a5c5b1fb5742c8d7846"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classllvm_1_1Record.html">Record</a> that <code>BB</code> is deleted after information was manifested.  <a href="structllvm_1_1Attributor.html#ad24ef41b2df43a5c5b1fb5742c8d7846">More...</a><br /></td></tr>
<tr class="separator:ad24ef41b2df43a5c5b1fb5742c8d7846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5341cc2229babd395097211c10b701c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a5341cc2229babd395097211c10b701c3">deleteAfterManifest</a> (<a class="el" href="classllvm_1_1Function.html">Function</a> &amp;<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>)</td></tr>
<tr class="memdesc:a5341cc2229babd395097211c10b701c3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classllvm_1_1Record.html">Record</a> that <code>F</code> is deleted after information was manifested.  <a href="structllvm_1_1Attributor.html#a5341cc2229babd395097211c10b701c3">More...</a><br /></td></tr>
<tr class="separator:a5341cc2229babd395097211c10b701c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bfa11d7b0e792a716558cf7265deeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1Constant.html">Constant</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a20bfa11d7b0e792a716558cf7265deeb">getAssumedConstant</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> &amp;V, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;AA, <a class="el" href="classbool.html">bool</a> &amp;UsedAssumedInformation)</td></tr>
<tr class="memdesc:a20bfa11d7b0e792a716558cf7265deeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>V</code> is assumed to be a constant, return it, if it is unclear yet, return None, otherwise return <code>nullptr</code>.  <a href="structllvm_1_1Attributor.html#a20bfa11d7b0e792a716558cf7265deeb">More...</a><br /></td></tr>
<tr class="separator:a20bfa11d7b0e792a716558cf7265deeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4064e320ddfad1e2ad635edb6ab9a35d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a4064e320ddfad1e2ad635edb6ab9a35d">isAssumedDead</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;AA, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AAIsDead.html">AAIsDead</a> *LivenessAA, <a class="el" href="classbool.html">bool</a> CheckBBLivenessOnly=<a class="el" href="VectorCombine_8cpp.html#a5a5a8a9d8745dc5abc3da0fe95f1ead4">false</a>, <a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a> DepClass=<a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1a7951811e4b085cf68ed3dc3191f36405">DepClassTy::OPTIONAL</a>)</td></tr>
<tr class="memdesc:a4064e320ddfad1e2ad635edb6ab9a35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>AA</code> (or its context instruction) is assumed dead.  <a href="structllvm_1_1Attributor.html#a4064e320ddfad1e2ad635edb6ab9a35d">More...</a><br /></td></tr>
<tr class="separator:a4064e320ddfad1e2ad635edb6ab9a35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be17997f8e04d24d77c2f9652689d60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a7be17997f8e04d24d77c2f9652689d60">isAssumedDead</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> *QueryingAA, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AAIsDead.html">AAIsDead</a> *LivenessAA, <a class="el" href="classbool.html">bool</a> CheckBBLivenessOnly=<a class="el" href="VectorCombine_8cpp.html#a5a5a8a9d8745dc5abc3da0fe95f1ead4">false</a>, <a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a> DepClass=<a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1a7951811e4b085cf68ed3dc3191f36405">DepClassTy::OPTIONAL</a>)</td></tr>
<tr class="memdesc:a7be17997f8e04d24d77c2f9652689d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>I</code> is assumed dead.  <a href="structllvm_1_1Attributor.html#a7be17997f8e04d24d77c2f9652689d60">More...</a><br /></td></tr>
<tr class="separator:a7be17997f8e04d24d77c2f9652689d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390fbf685d49602ff8928e70278e4e84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a390fbf685d49602ff8928e70278e4e84">isAssumedDead</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Use.html">Use</a> &amp;U, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> *QueryingAA, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AAIsDead.html">AAIsDead</a> *FnLivenessAA, <a class="el" href="classbool.html">bool</a> CheckBBLivenessOnly=<a class="el" href="VectorCombine_8cpp.html#a5a5a8a9d8745dc5abc3da0fe95f1ead4">false</a>, <a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a> DepClass=<a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1a7951811e4b085cf68ed3dc3191f36405">DepClassTy::OPTIONAL</a>)</td></tr>
<tr class="memdesc:a390fbf685d49602ff8928e70278e4e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>U</code> is assumed dead.  <a href="structllvm_1_1Attributor.html#a390fbf685d49602ff8928e70278e4e84">More...</a><br /></td></tr>
<tr class="separator:a390fbf685d49602ff8928e70278e4e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff7667b2e64531f0a17e91a8e051eed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a1ff7667b2e64531f0a17e91a8e051eed">isAssumedDead</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1IRPosition.html">IRPosition</a> &amp;IRP, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> *QueryingAA, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AAIsDead.html">AAIsDead</a> *FnLivenessAA, <a class="el" href="classbool.html">bool</a> CheckBBLivenessOnly=<a class="el" href="VectorCombine_8cpp.html#a5a5a8a9d8745dc5abc3da0fe95f1ead4">false</a>, <a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a> DepClass=<a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1a7951811e4b085cf68ed3dc3191f36405">DepClassTy::OPTIONAL</a>)</td></tr>
<tr class="memdesc:a1ff7667b2e64531f0a17e91a8e051eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>IRP</code> is assumed dead.  <a href="structllvm_1_1Attributor.html#a1ff7667b2e64531f0a17e91a8e051eed">More...</a><br /></td></tr>
<tr class="separator:a1ff7667b2e64531f0a17e91a8e051eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8bdb801d6f50f81bb9c5a9a18882b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a4b8bdb801d6f50f81bb9c5a9a18882b7">checkForAllUses</a> (<a class="el" href="classllvm_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Use.html">Use</a> &amp;, <a class="el" href="classbool.html">bool</a> &amp;)&gt; Pred, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;QueryingAA, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> &amp;V, <a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a> LivenessDepClass=<a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1a7951811e4b085cf68ed3dc3191f36405">DepClassTy::OPTIONAL</a>)</td></tr>
<tr class="memdesc:a4b8bdb801d6f50f81bb9c5a9a18882b7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacellvm_1_1Check.html">Check</a> <code>Pred</code> on all (transitive) uses of <code>V</code>.  <a href="structllvm_1_1Attributor.html#a4b8bdb801d6f50f81bb9c5a9a18882b7">More...</a><br /></td></tr>
<tr class="separator:a4b8bdb801d6f50f81bb9c5a9a18882b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273e9b97fc0dfec8df7cf4294d9b87fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a273e9b97fc0dfec8df7cf4294d9b87fe">isValidFunctionSignatureRewrite</a> (<a class="el" href="classllvm_1_1Argument.html">Argument</a> &amp;<a class="el" href="AMDGPULibCalls_8cpp.html#afecf1cc1292b07f57d343c0f4d682044">Arg</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt; ReplacementTypes)</td></tr>
<tr class="memdesc:a273e9b97fc0dfec8df7cf4294d9b87fe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacellvm_1_1Check.html">Check</a> if we can rewrite a function signature.  <a href="structllvm_1_1Attributor.html#a273e9b97fc0dfec8df7cf4294d9b87fe">More...</a><br /></td></tr>
<tr class="separator:a273e9b97fc0dfec8df7cf4294d9b87fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0121eb7b984a5cf2527133cb838d5982"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a0121eb7b984a5cf2527133cb838d5982">registerFunctionSignatureRewrite</a> (<a class="el" href="classllvm_1_1Argument.html">Argument</a> &amp;<a class="el" href="AMDGPULibCalls_8cpp.html#afecf1cc1292b07f57d343c0f4d682044">Arg</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt; ReplacementTypes, <a class="el" href="structllvm_1_1Attributor_1_1ArgumentReplacementInfo.html#adc6f45669e2fc1a2baa89257c597ee38">ArgumentReplacementInfo::CalleeRepairCBTy</a> &amp;&amp;CalleeRepairCB, <a class="el" href="structllvm_1_1Attributor_1_1ArgumentReplacementInfo.html#a6dd3a0b481598c505e99b524342c88ff">ArgumentReplacementInfo::ACSRepairCBTy</a> &amp;&amp;ACSRepairCB)</td></tr>
<tr class="memdesc:a0121eb7b984a5cf2527133cb838d5982"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classllvm_1_1Register.html" title="Wrapper class representing virtual and physical registers.">Register</a> a rewrite for a function signature.  <a href="structllvm_1_1Attributor.html#a0121eb7b984a5cf2527133cb838d5982">More...</a><br /></td></tr>
<tr class="separator:a0121eb7b984a5cf2527133cb838d5982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ac18ee77a7388be757c57636c8f0d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#ae9ac18ee77a7388be757c57636c8f0d6">checkForAllCallSites</a> (<a class="el" href="classllvm_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1AbstractCallSite.html">AbstractCallSite</a>)&gt; Pred, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;QueryingAA, <a class="el" href="classbool.html">bool</a> RequireAllCallSites, <a class="el" href="classbool.html">bool</a> &amp;AllCallSitesKnown)</td></tr>
<tr class="memdesc:ae9ac18ee77a7388be757c57636c8f0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacellvm_1_1Check.html">Check</a> <code>Pred</code> on all function call sites.  <a href="structllvm_1_1Attributor.html#ae9ac18ee77a7388be757c57636c8f0d6">More...</a><br /></td></tr>
<tr class="separator:ae9ac18ee77a7388be757c57636c8f0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544cc133c9a3caba81a887aa7826f7f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a544cc133c9a3caba81a887aa7826f7f3">checkForAllReturnedValuesAndReturnInsts</a> (<a class="el" href="classllvm_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1Value.html">Value</a> &amp;, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SmallSetVector.html">SmallSetVector</a>&lt; <a class="el" href="classllvm_1_1ReturnInst.html">ReturnInst</a> *, 4 &gt; &amp;)&gt; Pred, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;QueryingAA)</td></tr>
<tr class="memdesc:a544cc133c9a3caba81a887aa7826f7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacellvm_1_1Check.html">Check</a> <code>Pred</code> on all values potentially returned by <code>F</code>.  <a href="structllvm_1_1Attributor.html#a544cc133c9a3caba81a887aa7826f7f3">More...</a><br /></td></tr>
<tr class="separator:a544cc133c9a3caba81a887aa7826f7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7e4d740ecbe4916681549746b8690d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a9b7e4d740ecbe4916681549746b8690d">checkForAllReturnedValues</a> (<a class="el" href="classllvm_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1Value.html">Value</a> &amp;)&gt; Pred, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;QueryingAA)</td></tr>
<tr class="memdesc:a9b7e4d740ecbe4916681549746b8690d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacellvm_1_1Check.html">Check</a> <code>Pred</code> on all values potentially returned by the function associated with <code>QueryingAA</code>.  <a href="structllvm_1_1Attributor.html#a9b7e4d740ecbe4916681549746b8690d">More...</a><br /></td></tr>
<tr class="separator:a9b7e4d740ecbe4916681549746b8690d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de4bf7c9dca8a357ba870862ea39460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a9de4bf7c9dca8a357ba870862ea39460">checkForAllInstructions</a> (<a class="el" href="classllvm_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;)&gt; Pred, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;QueryingAA, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;Opcodes, <a class="el" href="classbool.html">bool</a> CheckBBLivenessOnly=<a class="el" href="VectorCombine_8cpp.html#a5a5a8a9d8745dc5abc3da0fe95f1ead4">false</a>)</td></tr>
<tr class="memdesc:a9de4bf7c9dca8a357ba870862ea39460"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacellvm_1_1Check.html">Check</a> <code>Pred</code> on all instructions with an opcode present in <code>Opcodes</code>.  <a href="structllvm_1_1Attributor.html#a9de4bf7c9dca8a357ba870862ea39460">More...</a><br /></td></tr>
<tr class="separator:a9de4bf7c9dca8a357ba870862ea39460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ddfeefe538a3d9a4368278d1e163ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a28ddfeefe538a3d9a4368278d1e163ba">checkForAllCallLikeInstructions</a> (<a class="el" href="classllvm_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;)&gt; Pred, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;QueryingAA)</td></tr>
<tr class="memdesc:a28ddfeefe538a3d9a4368278d1e163ba"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacellvm_1_1Check.html">Check</a> <code>Pred</code> on all call-like instructions (=CallBased derived).  <a href="structllvm_1_1Attributor.html#a28ddfeefe538a3d9a4368278d1e163ba">More...</a><br /></td></tr>
<tr class="separator:a28ddfeefe538a3d9a4368278d1e163ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b08cc18d69afabcd4b3e10b6f68671"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a28b08cc18d69afabcd4b3e10b6f68671">checkForAllReadWriteInstructions</a> (<a class="el" href="classllvm_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;)&gt; Pred, <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;QueryingAA)</td></tr>
<tr class="memdesc:a28b08cc18d69afabcd4b3e10b6f68671"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacellvm_1_1Check.html">Check</a> <code>Pred</code> on all Read/Write instructions.  <a href="structllvm_1_1Attributor.html#a28b08cc18d69afabcd4b3e10b6f68671">More...</a><br /></td></tr>
<tr class="separator:a28b08cc18d69afabcd4b3e10b6f68671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976c570e035996144da5e26f49eb1e31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a976c570e035996144da5e26f49eb1e31">getDataLayout</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a976c570e035996144da5e26f49eb1e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the data layout associated with the anchor scope.  <a href="structllvm_1_1Attributor.html#a976c570e035996144da5e26f49eb1e31">More...</a><br /></td></tr>
<tr class="separator:a976c570e035996144da5e26f49eb1e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a45f6cbf770c1d990014838ceb300e936"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a45f6cbf770c1d990014838ceb300e936">createShallowWrapper</a> (<a class="el" href="classllvm_1_1Function.html">Function</a> &amp;<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>)</td></tr>
<tr class="memdesc:a45f6cbf770c1d990014838ceb300e936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shallow wrapper for <code>F</code> such that <code>F</code> has internal linkage afterwards.  <a href="structllvm_1_1Attributor.html#a45f6cbf770c1d990014838ceb300e936">More...</a><br /></td></tr>
<tr class="separator:a45f6cbf770c1d990014838ceb300e936"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aeaab50c006df3da87c8813ea0715cecb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacellvm.html#a8e612822d4ba7bb36c9c79582a567108">BumpPtrAllocator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#aeaab50c006df3da87c8813ea0715cecb">Allocator</a></td></tr>
<tr class="memdesc:aeaab50c006df3da87c8813ea0715cecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allocator used to allocate memory, e.g. for <code><a class="el" href="structllvm_1_1AbstractAttribute.html" title="Base struct for all &quot;concrete attribute&quot; deductions.">AbstractAttribute</a></code>s.  <a href="structllvm_1_1Attributor.html#aeaab50c006df3da87c8813ea0715cecb">More...</a><br /></td></tr>
<tr class="separator:aeaab50c006df3da87c8813ea0715cecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The fixpoint analysis framework that orchestrates the attribute deduction. </p>
<p>The <a class="el" href="structllvm_1_1Attributor.html" title="The fixpoint analysis framework that orchestrates the attribute deduction.">Attributor</a> provides a general abstract analysis framework (guided fixpoint iteration) as well as helper functions for the deduction of (LLVM-IR) attributes. However, also other code properties can be deduced, propagated, and ultimately manifested through the <a class="el" href="structllvm_1_1Attributor.html" title="The fixpoint analysis framework that orchestrates the attribute deduction.">Attributor</a> framework. This is particularly useful if these properties interact with attributes and a co-scheduled deduction allows to improve the solution. Even if not, thus if attributes/properties are completely isolated, they should use the <a class="el" href="structllvm_1_1Attributor.html" title="The fixpoint analysis framework that orchestrates the attribute deduction.">Attributor</a> framework to reduce the number of fixpoint iteration frameworks in the code base. Note that the <a class="el" href="structllvm_1_1Attributor.html" title="The fixpoint analysis framework that orchestrates the attribute deduction.">Attributor</a> design makes sure that isolated attributes are not impacted, in any way, by others derived at the same time if there is no cross-reasoning performed.</p>
<p>The public facing interface of the <a class="el" href="structllvm_1_1Attributor.html" title="The fixpoint analysis framework that orchestrates the attribute deduction.">Attributor</a> is kept simple and basically allows abstract attributes to one thing, query abstract attributes in-flight. There are two reasons to do this: a) The optimistic state of one abstract attribute can justify an optimistic state of another, allowing to framework to end up with an optimistic (=best possible) fixpoint instead of one based solely on information in the IR. b) This avoids reimplementing various kinds of lookups, e.g., to check for existing IR attributes, in favor of a single lookups interface provided by an abstract attribute subclass.</p>
<p>NOTE: The mechanics of adding a new "concrete" abstract attribute are described in the file comment. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01010">1010</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a136f42a9aa18c9cda2a4ebeffa1f530e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136f42a9aa18c9cda2a4ebeffa1f530e">&#9670;&nbsp;</a></span>Attributor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Attributor::Attributor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SetVector.html">SetVector</a>&lt; <a class="el" href="classllvm_1_1Function.html">Function</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1InformationCache.html">InformationCache</a> &amp;&#160;</td>
          <td class="paramname"><em>InfoCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1CallGraphUpdater.html">CallGraphUpdater</a> &amp;&#160;</td>
          <td class="paramname"><em>CGUpdater</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> char * &gt; *&#160;</td>
          <td class="paramname"><em>Allowed</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Functions</td><td>The set of functions we are deriving attributes for. </td></tr>
    <tr><td class="paramname">InfoCache</td><td>Cache to hold various information accessible for the abstract attributes. </td></tr>
    <tr><td class="paramname">CGUpdater</td><td>Helper to update an underlying call graph. </td></tr>
    <tr><td class="paramname">Allowed</td><td>If not null, a set limiting the attribute opportunities. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01018">1018</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

</div>
</div>
<a id="a0ec7de1b5853de9ecb0a11eb2ac1c8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec7de1b5853de9ecb0a11eb2ac1c8d1">&#9670;&nbsp;</a></span>~Attributor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Attributor::~Attributor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l00561">561</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributor_8h_source.html#l00162">llvm::AADepGraphNode::Deps</a>, <a class="el" href="Attributor_8h_source.html#l00206">llvm::AADepGraph::SyntheticRoot</a>, and <a class="el" href="Attributor_8h_source.html#l02271">llvm::AbstractAttribute::~AbstractAttribute()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6e35504e47bdac806456a20c5a6ae2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e35504e47bdac806456a20c5a6ae2aa">&#9670;&nbsp;</a></span>changeToUnreachableAfterManifest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llvm::Attributor::changeToUnreachableAfterManifest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classllvm_1_1Record.html">Record</a> that <code>I</code> is to be replaced with <code>unreachable</code> after information was manifested. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01313">1313</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00059">I</a>.</p>

</div>
</div>
<a id="a95df269c34995fb5c2c123b4638a455b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95df269c34995fb5c2c123b4638a455b">&#9670;&nbsp;</a></span>changeUseAfterManifest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::Attributor::changeUseAfterManifest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Use.html">Use</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>NV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classllvm_1_1Record.html">Record</a> that <code>U</code> is to be replaces with <code>NV</code> after information was manifested. </p>
<p>This also triggers deletion of trivially dead istructions. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01287">1287</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="Value_8cpp_source.html#l00630">llvm::Value::stripPointerCasts()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributor_8h_source.html#l01301">changeValueAfterManifest()</a>.</p>

</div>
</div>
<a id="a8b8d03221cc6e2865ca2b6c28471b7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8d03221cc6e2865ca2b6c28471b7e9">&#9670;&nbsp;</a></span>changeValueAfterManifest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::Attributor::changeValueAfterManifest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>NV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>ChangeDroppable</em> = <code><a class="el" href="WebAssemblyExceptionInfo_8cpp.html#ade2a0fe2d2d0735c83fdc3ad5be1e1f2">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to replace all uses of <code>V</code> with <code>NV</code>. </p>
<p>Return true if there is any change. The flag <code>ChangeDroppable</code> indicates if dropppable uses should be changed too. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01301">1301</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

<p class="reference">References <a class="el" href="Attributor_8h_source.html#l01287">changeUseAfterManifest()</a>, and <a class="el" href="Value_8h_source.html#l00379">llvm::Value::uses()</a>.</p>

</div>
</div>
<a id="a28ddfeefe538a3d9a4368278d1e163ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ddfeefe538a3d9a4368278d1e163ba">&#9670;&nbsp;</a></span>checkForAllCallLikeInstructions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::Attributor::checkForAllCallLikeInstructions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>QueryingAA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacellvm_1_1Check.html">Check</a> <code>Pred</code> on all call-like instructions (=CallBased derived). </p>
<p>See checkForAllCallLikeInstructions(...) for more information. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01521">1521</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

<p class="reference">References <a class="el" href="MCInstrDesc_8h_source.html#l00154">llvm::MCID::Call</a>, and <a class="el" href="Attributor_8cpp_source.html#l00919">checkForAllInstructions()</a>.</p>

</div>
</div>
<a id="ae9ac18ee77a7388be757c57636c8f0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ac18ee77a7388be757c57636c8f0d6">&#9670;&nbsp;</a></span>checkForAllCallSites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Attributor::checkForAllCallSites </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1AbstractCallSite.html">AbstractCallSite</a>)&gt;&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>QueryingAA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>RequireAllCallSites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>AllCallSitesKnown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacellvm_1_1Check.html">Check</a> <code>Pred</code> on all function call sites. </p>
<p>This method will evaluate <code>Pred</code> on call sites and return true if <code>Pred</code> holds in every call sites. However, this is only possible all call sites are known, hence the function has internal linkage. If true is returned, <code>AllCallSitesKnown</code> is set if all possible call sites of the function have been visited. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l00748">748</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="Attributor_8h_source.html#l00339">llvm::IRPosition::getAssociatedFunction()</a>, <a class="el" href="Attributor_8h_source.html#l02296">llvm::AbstractAttribute::getIRPosition()</a>, and <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributor_8cpp_source.html#l01538">isValidFunctionSignatureRewrite()</a>.</p>

</div>
</div>
<a id="a9de4bf7c9dca8a357ba870862ea39460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de4bf7c9dca8a357ba870862ea39460">&#9670;&nbsp;</a></span>checkForAllInstructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Attributor::checkForAllInstructions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>QueryingAA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Opcodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>CheckBBLivenessOnly</em> = <code><a class="el" href="VectorCombine_8cpp.html#a5a5a8a9d8745dc5abc3da0fe95f1ead4">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacellvm_1_1Check.html">Check</a> <code>Pred</code> on all instructions with an opcode present in <code>Opcodes</code>. </p>
<p>This method will evaluate <code>Pred</code> on all instructions with an opcode present in <code>Opcode</code> and return true if <code>Pred</code> holds on all of them. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l00919">919</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributor_8cpp_source.html#l00895">checkForAllInstructionsImpl()</a>, <a class="el" href="Attributor_8h_source.html#l00260">llvm::IRPosition::function()</a>, <a class="el" href="Attributor_8h_source.html#l00339">llvm::IRPosition::getAssociatedFunction()</a>, <a class="el" href="Attributor_8h_source.html#l02296">llvm::AbstractAttribute::getIRPosition()</a>, and <a class="el" href="Attributor_8h_source.html#l00847">llvm::InformationCache::getOpcodeInstMapForFunction()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributor_8h_source.html#l01521">checkForAllCallLikeInstructions()</a>.</p>

</div>
</div>
<a id="a28b08cc18d69afabcd4b3e10b6f68671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b08cc18d69afabcd4b3e10b6f68671">&#9670;&nbsp;</a></span>checkForAllReadWriteInstructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Attributor::checkForAllReadWriteInstructions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>QueryingAA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacellvm_1_1Check.html">Check</a> <code>Pred</code> on all Read/Write instructions. </p>
<p>This method will evaluate <code>Pred</code> on all instructions that read or write to memory present in the information cache and return true if <code>Pred</code> holds on all of them. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l00946">946</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributor_8h_source.html#l00260">llvm::IRPosition::function()</a>, <a class="el" href="Attributor_8h_source.html#l00339">llvm::IRPosition::getAssociatedFunction()</a>, <a class="el" href="Attributor_8h_source.html#l02296">llvm::AbstractAttribute::getIRPosition()</a>, <a class="el" href="Attributor_8h_source.html#l00852">llvm::InformationCache::getReadOrWriteInstsForFunction()</a>, <a class="el" href="MD5_8cpp_source.html#l00059">I</a>, <a class="el" href="Attributor_8cpp_source.html#l00570">isAssumedDead()</a>, and <a class="el" href="Attributor_8h_source.html#l00251">llvm::IRPosition::value()</a>.</p>

</div>
</div>
<a id="a9b7e4d740ecbe4916681549746b8690d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7e4d740ecbe4916681549746b8690d">&#9670;&nbsp;</a></span>checkForAllReturnedValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Attributor::checkForAllReturnedValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1Value.html">Value</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>QueryingAA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacellvm_1_1Check.html">Check</a> <code>Pred</code> on all values potentially returned by the function associated with <code>QueryingAA</code>. </p>
<p>This is the context insensitive version of the method above. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l00875">875</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributor_8h_source.html#l00260">llvm::IRPosition::function()</a>, <a class="el" href="Attributor_8h_source.html#l00339">llvm::IRPosition::getAssociatedFunction()</a>, and <a class="el" href="Attributor_8h_source.html#l02296">llvm::AbstractAttribute::getIRPosition()</a>.</p>

</div>
</div>
<a id="a544cc133c9a3caba81a887aa7826f7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544cc133c9a3caba81a887aa7826f7f3">&#9670;&nbsp;</a></span>checkForAllReturnedValuesAndReturnInsts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Attributor::checkForAllReturnedValuesAndReturnInsts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1Value.html">Value</a> &amp;, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SmallSetVector.html">SmallSetVector</a>&lt; <a class="el" href="classllvm_1_1ReturnInst.html">ReturnInst</a> *, 4 &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>QueryingAA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacellvm_1_1Check.html">Check</a> <code>Pred</code> on all values potentially returned by <code>F</code>. </p>
<p>This method will evaluate <code>Pred</code> on all values potentially returned by the function associated with <code>QueryingAA</code>. The returned values are matched with their respective return instructions. Returns true if <code>Pred</code> holds on all of them. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l00853">853</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributor_8h_source.html#l00260">llvm::IRPosition::function()</a>, <a class="el" href="Attributor_8h_source.html#l00339">llvm::IRPosition::getAssociatedFunction()</a>, and <a class="el" href="Attributor_8h_source.html#l02296">llvm::AbstractAttribute::getIRPosition()</a>.</p>

</div>
</div>
<a id="a4b8bdb801d6f50f81bb9c5a9a18882b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8bdb801d6f50f81bb9c5a9a18882b7">&#9670;&nbsp;</a></span>checkForAllUses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Attributor::checkForAllUses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Use.html">Use</a> &amp;, <a class="el" href="classbool.html">bool</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>QueryingAA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a>&#160;</td>
          <td class="paramname"><em>LivenessDepClass</em> = <code><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1a7951811e4b085cf68ed3dc3191f36405">DepClassTy::OPTIONAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacellvm_1_1Check.html">Check</a> <code>Pred</code> on all (transitive) uses of <code>V</code>. </p>
<p>This method will evaluate <code>Pred</code> on all (transitive) uses of the associated value and return true if <code>Pred</code> holds every time. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l00683">683</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="NVVMIntrRange_8cpp_source.html#l00061">C</a>, <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="SmallVector_8h_source.html#l00073">llvm::SmallVectorBase&lt; Size_T &gt;::empty()</a>, <a class="el" href="Attributor_8h_source.html#l00260">llvm::IRPosition::function()</a>, <a class="el" href="Attributor_8h_source.html#l00368">llvm::IRPosition::getAnchorScope()</a>, <a class="el" href="Attributor_8cpp_source.html#l00535">getAssumedConstant()</a>, <a class="el" href="Attributor_8h_source.html#l02296">llvm::AbstractAttribute::getIRPosition()</a>, <a class="el" href="SmallPtrSet_8h_source.html#l00364">llvm::SmallPtrSetImpl&lt; PtrType &gt;::insert()</a>, <a class="el" href="Attributor_8cpp_source.html#l00570">isAssumedDead()</a>, <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>, <a class="el" href="SmallVector_8h_source.html#l00635">llvm::SmallVectorImpl&lt; T &gt;::pop_back_val()</a>, <a class="el" href="SmallVector_8h_source.html#l00404">llvm::SmallVectorTemplateBase&lt; T, bool &gt;::push_back()</a>, <a class="el" href="SmallVector_8h_source.html#l00070">llvm::SmallVectorBase&lt; Size_T &gt;::size()</a>, <a class="el" href="Value_8h_source.html#l00347">llvm::Value::use_empty()</a>, and <a class="el" href="Value_8h_source.html#l00379">llvm::Value::uses()</a>.</p>

</div>
</div>
<a id="a45f6cbf770c1d990014838ceb300e936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f6cbf770c1d990014838ceb300e936">&#9670;&nbsp;</a></span>createShallowWrapper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Attributor::createShallowWrapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a shallow wrapper for <code>F</code> such that <code>F</code> has internal linkage afterwards. </p>
<p>It also sets the original <code>F</code> 's name to anonymous</p>
<p>A wrapper is a function with the same type (and attributes) as <code>F</code> that will only call <code>F</code> and return the result, if any.</p>
<p>Assuming the declaration of looks like: rty <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F(aty0 arg0, ..., atyN argN)</a>;</p>
<p>The wrapper will then look as follows: rty wrapper(aty0 arg0, ..., atyN argN) { return <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F(arg0, ..., argN)</a>; } </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l01441">1441</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstrTypes_8h_source.html#l01475">llvm::CallBase::addAttribute()</a>, <a class="el" href="AMDGPULibCalls_8cpp_source.html#l00205">Arg</a>, <a class="el" href="AMDGPUMetadata_8h_source.html#l00379">llvm::AMDGPU::HSAMD::Kernel::Key::Args</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Function_8h_source.html#l00137">llvm::Function::Create()</a>, <a class="el" href="Instructions_8h_source.html#l01493">llvm::CallInst::Create()</a>, <a class="el" href="Instructions_8h_source.html#l02960">llvm::ReturnInst::Create()</a>, <a class="el" href="BasicBlock_8h_source.html#l00100">llvm::BasicBlock::Create()</a>, <a class="el" href="MD5_8cpp_source.html#l00056">F</a>, <a class="el" href="Attributes_8h_source.html#l00369">llvm::AttributeList::FunctionIndex</a>, <a class="el" href="ProvenanceAnalysisEvaluator_8cpp_source.html#l00042">getName()</a>, <a class="el" href="Value_8h_source.html#l00246">llvm::Value::getType()</a>, <a class="el" href="GlobalValue_8h_source.html#l00055">llvm::GlobalValue::InternalLinkage</a>, <a class="el" href="Type_8h_source.html#l00139">llvm::Type::isVoidTy()</a>, <a class="el" href="Instructions_8h_source.html#l01667">llvm::CallInst::setTailCall()</a>, and <a class="el" href="AMDGPUAliasAnalysis_8cpp_source.html#l00030">Wrapper</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributor_8cpp_source.html#l02275">runAttributorOnFunctions()</a>.</p>

</div>
</div>
<a id="ad24ef41b2df43a5c5b1fb5742c8d7846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24ef41b2df43a5c5b1fb5742c8d7846">&#9670;&nbsp;</a></span>deleteAfterManifest() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llvm::Attributor::deleteAfterManifest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>BB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classllvm_1_1Record.html">Record</a> that <code>BB</code> is deleted after information was manifested. </p>
<p>This also triggers deletion of trivially dead istructions. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01330">1330</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

</div>
</div>
<a id="a5341cc2229babd395097211c10b701c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5341cc2229babd395097211c10b701c3">&#9670;&nbsp;</a></span>deleteAfterManifest() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llvm::Attributor::deleteAfterManifest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classllvm_1_1Record.html">Record</a> that <code>F</code> is deleted after information was manifested. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01333">1333</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00056">F</a>.</p>

</div>
</div>
<a id="ac721eb1fd5b7055e86b73192d40516fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac721eb1fd5b7055e86b73192d40516fd">&#9670;&nbsp;</a></span>deleteAfterManifest() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llvm::Attributor::deleteAfterManifest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classllvm_1_1Record.html">Record</a> that <code>I</code> is deleted after information was manifested. </p>
<p>This also triggers deletion of trivially dead istructions. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01326">1326</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00059">I</a>.</p>

</div>
</div>
<a id="a48d51ee51525dec4ed3041a6cadcbb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d51ee51525dec4ed3041a6cadcbb27">&#9670;&nbsp;</a></span>getAAFor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AAType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> AAType&amp; llvm::Attributor::getAAFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>QueryingAA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1IRPosition.html">IRPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>IRP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>TrackDependence</em> = <code><a class="el" href="WebAssemblyExceptionInfo_8cpp.html#ade2a0fe2d2d0735c83fdc3ad5be1e1f2">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a>&#160;</td>
          <td class="paramname"><em>DepClass</em> = <code><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1aebdf9721be38d1fc1cd6db8c737d1be0">DepClassTy::REQUIRED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup an abstract attribute of type <code>AAType</code> at position <code>IRP</code>. </p>
<p>While no abstract attribute is found equivalent positions are checked, see <a class="el" href="classllvm_1_1SubsumingPositionIterator.html" title="A visitor class for IR positions.">SubsumingPositionIterator</a>. Thus, the returned abstract attribute might be anchored at a different position, e.g., the callee if <code>IRP</code> is a call base.</p>
<p>This method is the only (supported) way an abstract attribute can retrieve information from another abstract attribute. As an example, take an abstract attribute that determines the memory access behavior for a argument (readnone, readonly, ...). It should use <code>getAAFor</code> to get the most optimistic information for other abstract attributes in-flight, e.g. the one reasoning about the "captured" state for the argument or the one reasoning on the memory access behavior of the function as a whole.</p>
<p>If the flag <code>TrackDependence</code> is set to false the dependence from <code>QueryingAA</code> to the return abstract attribute is not automatically recorded. This should only be used if the caller will record the dependence explicitly if necessary, thus if it the returned abstract attribute is used for reasoning. To record the dependences explicitly use the <code><a class="el" href="structllvm_1_1Attributor.html#a44cbebd01cb4b697d9f6827de7e5acee" title="Explicitly record a dependence from FromAA to ToAA, that is if FromAA changes ToAA should be updated ...">Attributor::recordDependence</a></code> method. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01055">1055</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

</div>
</div>
<a id="a7cc3fc31180e8449aa7ebe02af30f790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc3fc31180e8449aa7ebe02af30f790">&#9670;&nbsp;</a></span>getAndUpdateAAFor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AAType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> AAType&amp; llvm::Attributor::getAndUpdateAAFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>QueryingAA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1IRPosition.html">IRPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>IRP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>TrackDependence</em> = <code><a class="el" href="WebAssemblyExceptionInfo_8cpp.html#ade2a0fe2d2d0735c83fdc3ad5be1e1f2">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a>&#160;</td>
          <td class="paramname"><em>DepClass</em> = <code><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1aebdf9721be38d1fc1cd6db8c737d1be0">DepClassTy::REQUIRED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to getAAFor but the return abstract attribute will be updated (via <code><a class="el" href="structllvm_1_1AbstractAttribute.html#a03972b18e36635ccda4c5a26891f0d25" title="Hook for the Attributor to trigger an update of the internal state.">AbstractAttribute::update</a></code>) even if it is found in the cache. </p>
<p>This is especially useful for <a class="el" href="structllvm_1_1AAIsDead.html" title="An abstract interface for liveness abstract attribute.">AAIsDead</a> as changes in liveness can make updates possible/useful that were not happening before as the abstract attribute was assumed dead. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01068">1068</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

</div>
</div>
<a id="a20bfa11d7b0e792a716558cf7265deeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20bfa11d7b0e792a716558cf7265deeb">&#9670;&nbsp;</a></span>getAssumedConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1Constant.html">Constant</a> * &gt; Attributor::getAssumedConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>AA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>UsedAssumedInformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>V</code> is assumed to be a constant, return it, if it is unclear yet, return None, otherwise return <code>nullptr</code>. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l00535">535</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00246">llvm::Value::getType()</a>, <a class="el" href="Optional_8h_source.html#l00280">llvm::Optional&lt; T &gt;::getValue()</a>, <a class="el" href="Optional_8h_source.html#l00286">llvm::Optional&lt; T &gt;::hasValue()</a>, <a class="el" href="None_8h_source.html#l00023">llvm::None</a>, <a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1a7951811e4b085cf68ed3dc3191f36405">llvm::OPTIONAL</a>, <a class="el" href="Attributor_8cpp_source.html#l01923">recordDependence()</a>, and <a class="el" href="Attributor_8h_source.html#l00251">llvm::IRPosition::value()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributor_8cpp_source.html#l00683">checkForAllUses()</a>.</p>

</div>
</div>
<a id="a976c570e035996144da5e26f49eb1e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976c570e035996144da5e26f49eb1e31">&#9670;&nbsp;</a></span>getDataLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a>&amp; llvm::Attributor::getDataLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the data layout associated with the anchor scope. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01554">1554</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

</div>
</div>
<a id="a367f5a7c00648f2fdd4eb72f55393d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367f5a7c00648f2fdd4eb72f55393d48">&#9670;&nbsp;</a></span>getInfoCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structllvm_1_1InformationCache.html">InformationCache</a>&amp; llvm::Attributor::getInfoCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the internal information cache. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01233">1233</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributor_8h_source.html#l01082">getOrCreateAAFor()</a>.</p>

</div>
</div>
<a id="a047bd0070c7f82b4d31a020a82a2d719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047bd0070c7f82b4d31a020a82a2d719">&#9670;&nbsp;</a></span>getOrCreateAAFor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AAType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> AAType&amp; llvm::Attributor::getOrCreateAAFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1IRPosition.html">IRPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>IRP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> *&#160;</td>
          <td class="paramname"><em>QueryingAA</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>TrackDependence</em> = <code><a class="el" href="VectorCombine_8cpp.html#a5a5a8a9d8745dc5abc3da0fe95f1ead4">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a>&#160;</td>
          <td class="paramname"><em>DepClass</em> = <code><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1a7951811e4b085cf68ed3dc3191f36405">DepClassTy::OPTIONAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>ForceUpdate</em> = <code><a class="el" href="VectorCombine_8cpp.html#a5a5a8a9d8745dc5abc3da0fe95f1ead4">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The version of getAAFor that allows to omit a querying abstract attribute. </p>
<p>Using this after <a class="el" href="structllvm_1_1Attributor.html" title="The fixpoint analysis framework that orchestrates the attribute deduction.">Attributor</a> started running is restricted to only the <a class="el" href="structllvm_1_1Attributor.html" title="The fixpoint analysis framework that orchestrates the attribute deduction.">Attributor</a> itself. Initial seeding of AAs can be done via this function. NOTE: ForceUpdate is ignored in any stage other than the update stage. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01082">1082</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

<p class="reference">References <a class="el" href="DenseSet_8h_source.html#l00097">llvm::detail::DenseSetImpl&lt; ValueT, MapTy, ValueInfoT &gt;::count()</a>, <a class="el" href="Attributor_8h_source.html#l00368">llvm::IRPosition::getAnchorScope()</a>, <a class="el" href="Attributor_8h_source.html#l01233">getInfoCache()</a>, <a class="el" href="Function_8h_source.html#l00345">llvm::Function::hasFnAttribute()</a>, <a class="el" href="Attributor_8cpp_source.html#l00086">llvm::MaxInitializationChainLength</a>, <a class="el" href="Attributor_8cpp_source.html#l01923">recordDependence()</a>, and <a class="el" href="Attributor_8h_source.html#l01212">registerAA()</a>.</p>

</div>
</div>
<a id="adab9b2e1a33cfbe6f0fa6443046dcaf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab9b2e1a33cfbe6f0fa6443046dcaf8">&#9670;&nbsp;</a></span>identifyDefaultAbstractAttributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Attributor::identifyDefaultAbstractAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine opportunities to derive 'default' attributes in <code>F</code> and create abstract attribute objects for them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>The function that is checked for attribute opportunities.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that abstract attribute instances are generally created even if the IR already contains the information they would deduce. The most important reason for this is the single interface, the one of the abstract attribute instance, which can be queried without the need to look at the IR in various places. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l01946">1946</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributor_8cpp.html#a52d8a42147fe0e2f934be490eb40175d">AnnotateDeclarationCallSites</a>, <a class="el" href="AMDGPULibCalls_8cpp_source.html#l00205">Arg</a>, <a class="el" href="Attributor_8h_source.html#l00270">llvm::IRPosition::argument()</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="MCInstrDesc_8h_source.html#l00154">llvm::MCID::Call</a>, <a class="el" href="AMDGPULibCalls_8cpp_source.html#l00205">Callee</a>, <a class="el" href="Attributor_8h_source.html#l00285">llvm::IRPosition::callsite_argument()</a>, <a class="el" href="Attributor_8h_source.html#l00280">llvm::IRPosition::callsite_returned()</a>, <a class="el" href="Attributor_8cpp_source.html#l00895">checkForAllInstructionsImpl()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a6742d2e0a668baf1196ec69e158d5f15">E</a>, <a class="el" href="Attributor_8cpp.html#abaffe76a983cdb91d6b4da3ae7ac9b51">EnableHeapToStack</a>, <a class="el" href="MD5_8cpp_source.html#l00056">F</a>, <a class="el" href="Attributor_8h_source.html#l00260">llvm::IRPosition::function()</a>, <a class="el" href="Attributor_8h_source.html#l00847">llvm::InformationCache::getOpcodeInstMapForFunction()</a>, <a class="el" href="Instructions_8h_source.html#l05271">llvm::getPointerOperand()</a>, <a class="el" href="Use_8h_source.html#l00073">llvm::Use::getUser()</a>, <a class="el" href="MD5_8cpp_source.html#l00059">I</a>, <a class="el" href="Attributor_8h_source.html#l01236">isModulePass()</a>, <a class="el" href="SparcInstrInfo_8h_source.html#l00032">llvm::SPII::Load</a>, <a class="el" href="Attributor_8h_source.html#l00265">llvm::IRPosition::returned()</a>, <a class="el" href="SparcInstrInfo_8h_source.html#l00033">llvm::SPII::Store</a>, <a class="el" href="AArch64Disassembler_8cpp_source.html#l00248">Success</a>, and <a class="el" href="Attributor_8h_source.html#l00251">llvm::IRPosition::value()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributor_8h_source.html#l01270">markLiveInternalFunction()</a>.</p>

</div>
</div>
<a id="a4064e320ddfad1e2ad635edb6ab9a35d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4064e320ddfad1e2ad635edb6ab9a35d">&#9670;&nbsp;</a></span>isAssumedDead() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Attributor::isAssumedDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>AA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AAIsDead.html">AAIsDead</a> *&#160;</td>
          <td class="paramname"><em>LivenessAA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>CheckBBLivenessOnly</em> = <code><a class="el" href="VectorCombine_8cpp.html#a5a5a8a9d8745dc5abc3da0fe95f1ead4">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a>&#160;</td>
          <td class="paramname"><em>DepClass</em> = <code><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1a7951811e4b085cf68ed3dc3191f36405">DepClassTy::OPTIONAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <code>AA</code> (or its context instruction) is assumed dead. </p>
<p>If <code>LivenessAA</code> is not provided it is queried. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l00570">570</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributor_8h_source.html#l00368">llvm::IRPosition::getAnchorScope()</a>, and <a class="el" href="Attributor_8h_source.html#l02296">llvm::AbstractAttribute::getIRPosition()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributor_8cpp_source.html#l00946">checkForAllReadWriteInstructions()</a>, <a class="el" href="Attributor_8cpp_source.html#l00683">checkForAllUses()</a>, and <a class="el" href="Attributor_8cpp_source.html#l00579">isAssumedDead()</a>.</p>

</div>
</div>
<a id="a7be17997f8e04d24d77c2f9652689d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be17997f8e04d24d77c2f9652689d60">&#9670;&nbsp;</a></span>isAssumedDead() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Attributor::isAssumedDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> *&#160;</td>
          <td class="paramname"><em>QueryingAA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AAIsDead.html">AAIsDead</a> *&#160;</td>
          <td class="paramname"><em>LivenessAA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>CheckBBLivenessOnly</em> = <code><a class="el" href="VectorCombine_8cpp.html#a5a5a8a9d8745dc5abc3da0fe95f1ead4">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a>&#160;</td>
          <td class="paramname"><em>DepClass</em> = <code><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1a7951811e4b085cf68ed3dc3191f36405">DepClassTy::OPTIONAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <code>I</code> is assumed dead. </p>
<p>If <code>LivenessAA</code> is not provided it is queried. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l00611">611</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributor_8h_source.html#l00260">llvm::IRPosition::function()</a>, <a class="el" href="Attributor_8h_source.html#l00368">llvm::IRPosition::getAnchorScope()</a>, <a class="el" href="Attributor_8h_source.html#l02296">llvm::AbstractAttribute::getIRPosition()</a>, <a class="el" href="MD5_8cpp_source.html#l00059">I</a>, <a class="el" href="structllvm_1_1AAIsDead.html#a5092ee8377153501a5d1cb113d15d073">llvm::AAIsDead::isAssumedDead()</a>, <a class="el" href="Attributor_8cpp_source.html#l01923">recordDependence()</a>, and <a class="el" href="Attributor_8h_source.html#l00251">llvm::IRPosition::value()</a>.</p>

</div>
</div>
<a id="a1ff7667b2e64531f0a17e91a8e051eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff7667b2e64531f0a17e91a8e051eed">&#9670;&nbsp;</a></span>isAssumedDead() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Attributor::isAssumedDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1IRPosition.html">IRPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>IRP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> *&#160;</td>
          <td class="paramname"><em>QueryingAA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AAIsDead.html">AAIsDead</a> *&#160;</td>
          <td class="paramname"><em>FnLivenessAA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>CheckBBLivenessOnly</em> = <code><a class="el" href="VectorCombine_8cpp.html#a5a5a8a9d8745dc5abc3da0fe95f1ead4">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a>&#160;</td>
          <td class="paramname"><em>DepClass</em> = <code><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1a7951811e4b085cf68ed3dc3191f36405">DepClassTy::OPTIONAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <code>IRP</code> is assumed dead. </p>
<p>If <code>FnLivenessAA</code> is not provided it is queried. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l00647">647</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributor_8h_source.html#l00280">llvm::IRPosition::callsite_returned()</a>, <a class="el" href="Attributor_8h_source.html#l00394">llvm::IRPosition::getAssociatedValue()</a>, <a class="el" href="Attributor_8h_source.html#l00380">llvm::IRPosition::getCtxI()</a>, <a class="el" href="Attributor_8h_source.html#l00448">llvm::IRPosition::getPositionKind()</a>, <a class="el" href="Attributor_8h_source.html#l00240">llvm::IRPosition::IRP_CALL_SITE</a>, <a class="el" href="structllvm_1_1AAIsDead.html#a5092ee8377153501a5d1cb113d15d073">llvm::AAIsDead::isAssumedDead()</a>, <a class="el" href="Attributor_8cpp_source.html#l00570">isAssumedDead()</a>, <a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1a7951811e4b085cf68ed3dc3191f36405">llvm::OPTIONAL</a>, and <a class="el" href="Attributor_8cpp_source.html#l01923">recordDependence()</a>.</p>

</div>
</div>
<a id="a390fbf685d49602ff8928e70278e4e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390fbf685d49602ff8928e70278e4e84">&#9670;&nbsp;</a></span>isAssumedDead() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Attributor::isAssumedDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Use.html">Use</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> *&#160;</td>
          <td class="paramname"><em>QueryingAA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AAIsDead.html">AAIsDead</a> *&#160;</td>
          <td class="paramname"><em>FnLivenessAA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>CheckBBLivenessOnly</em> = <code><a class="el" href="VectorCombine_8cpp.html#a5a5a8a9d8745dc5abc3da0fe95f1ead4">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a>&#160;</td>
          <td class="paramname"><em>DepClass</em> = <code><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1a7951811e4b085cf68ed3dc3191f36405">DepClassTy::OPTIONAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <code>U</code> is assumed dead. </p>
<p>If <code>FnLivenessAA</code> is not provided it is queried. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l00579">579</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributor_8h_source.html#l00285">llvm::IRPosition::callsite_argument()</a>, <a class="el" href="Use_8h_source.html#l00067">llvm::Use::get()</a>, <a class="el" href="BasicBlock_8cpp_source.html#l00148">llvm::BasicBlock::getTerminator()</a>, <a class="el" href="Use_8h_source.html#l00073">llvm::Use::getUser()</a>, <a class="el" href="Attributor_8cpp_source.html#l00570">isAssumedDead()</a>, <a class="el" href="Attributor_8h_source.html#l00265">llvm::IRPosition::returned()</a>, and <a class="el" href="Attributor_8h_source.html#l00251">llvm::IRPosition::value()</a>.</p>

</div>
</div>
<a id="a596c00dc88e93bcbe9f9c58b0c1f23bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596c00dc88e93bcbe9f9c58b0c1f23bb">&#9670;&nbsp;</a></span>isFunctionIPOAmendable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::Attributor::isFunctionIPOAmendable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the function <code>F</code> is IPO amendable. </p>
<p>If a function is exactly defined or it has alwaysinline attribute and is viable to be inlined, we say it is IPO amendable </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01262">1262</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00056">F</a>.</p>

</div>
</div>
<a id="a16c57fa54ffac78fa93b5a1d6f9eb4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c57fa54ffac78fa93b5a1d6f9eb4eb">&#9670;&nbsp;</a></span>isModulePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::Attributor::isModulePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this is a module pass, false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01236">1236</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributor_8cpp_source.html#l01946">identifyDefaultAbstractAttributes()</a>.</p>

</div>
</div>
<a id="a3853ed90dd9241284f8bc645e6363ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3853ed90dd9241284f8bc645e6363ee8">&#9670;&nbsp;</a></span>isRunOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::Attributor::isRunOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>Fn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if we derive attributes for <code>Fn</code>. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01242">1242</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

</div>
</div>
<a id="a273e9b97fc0dfec8df7cf4294d9b87fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273e9b97fc0dfec8df7cf4294d9b87fe">&#9670;&nbsp;</a></span>isValidFunctionSignatureRewrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Attributor::isValidFunctionSignatureRewrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Argument.html">Argument</a> &amp;&#160;</td>
          <td class="paramname"><em>Arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt;&#160;</td>
          <td class="paramname"><em>ReplacementTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacellvm_1_1Check.html">Check</a> if we can rewrite a function signature. </p>
<p>The argument <code>Arg</code> is replaced with new ones defined by the number, order, and types in <code>ReplacementTypes</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>True, if the replacement can be registered, via registerFunctionSignatureRewrite, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l01538">1538</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="AMDGPULibCalls_8cpp_source.html#l00205">Arg</a>, <a class="el" href="MCInstrDesc_8h_source.html#l00154">llvm::MCID::Call</a>, <a class="el" href="Attributor_8cpp_source.html#l00748">checkForAllCallSites()</a>, <a class="el" href="Attributor_8cpp_source.html#l00895">checkForAllInstructionsImpl()</a>, <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="Function_8h_source.html#l00239">llvm::Function::getAttributes()</a>, <a class="el" href="AbstractCallSite_8h_source.html#l00218">llvm::AbstractCallSite::getCalledFunction()</a>, <a class="el" href="AbstractCallSite_8h_source.html#l00112">llvm::AbstractCallSite::getInstruction()</a>, <a class="el" href="Attributor_8h_source.html#l00847">llvm::InformationCache::getOpcodeInstMapForFunction()</a>, <a class="el" href="Function_8h_source.html#l00170">llvm::Function::getReturnType()</a>, <a class="el" href="Value_8h_source.html#l00246">llvm::Value::getType()</a>, <a class="el" href="Attributes_8cpp_source.html#l01472">llvm::AttributeList::hasAttrSomewhere()</a>, <a class="el" href="MD5_8cpp_source.html#l00059">I</a>, <a class="el" href="AbstractCallSite_8h_source.html#l00125">llvm::AbstractCallSite::isCallbackCall()</a>, <a class="el" href="Instructions_8cpp_source.html#l00281">llvm::CallBase::isMustTailCall()</a>, <a class="el" href="Function_8h_source.html#l00178">llvm::Function::isVarArg()</a>, and <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributor_8cpp_source.html#l01597">registerFunctionSignatureRewrite()</a>.</p>

</div>
</div>
<a id="aba32c0affd7a3a54e207cdd8a58f6949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba32c0affd7a3a54e207cdd8a58f6949">&#9670;&nbsp;</a></span>lookupAAFor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AAType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AAType* llvm::Attributor::lookupAAFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1IRPosition.html">IRPosition</a> &amp;&#160;</td>
          <td class="paramname"><em>IRP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> *&#160;</td>
          <td class="paramname"><em>QueryingAA</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>TrackDependence</em> = <code><a class="el" href="VectorCombine_8cpp.html#a5a5a8a9d8745dc5abc3da0fe95f1ead4">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a>&#160;</td>
          <td class="paramname"><em>DepClass</em> = <code><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1a7951811e4b085cf68ed3dc3191f36405">DepClassTy::OPTIONAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the attribute of <code>AAType</code> for <code>IRP</code> if existing. </p>
<p>This also allows non-AA users lookup. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01166">1166</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="Attributor_8cpp_source.html#l01923">recordDependence()</a>.</p>

</div>
</div>
<a id="aad329ad4e840a3849e8cad4d3daed329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad329ad4e840a3849e8cad4d3daed329">&#9670;&nbsp;</a></span>markLiveInternalFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llvm::Attributor::markLiveInternalFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the internal function <code>F</code> as live. </p>
<p>This will trigger the identification and initialization of attributes for <code>F</code>. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01270">1270</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="MD5_8cpp_source.html#l00056">F</a>, and <a class="el" href="Attributor_8cpp_source.html#l01946">identifyDefaultAbstractAttributes()</a>.</p>

</div>
</div>
<a id="a44cbebd01cb4b697d9f6827de7e5acee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cbebd01cb4b697d9f6827de7e5acee">&#9670;&nbsp;</a></span>recordDependence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Attributor::recordDependence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>FromAA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>ToAA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a>&#160;</td>
          <td class="paramname"><em>DepClass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly record a dependence from <code>FromAA</code> to <code>ToAA</code>, that is if <code>FromAA</code> changes <code>ToAA</code> should be updated as well. </p>
<p>This method should be used in conjunction with the <code>getAAFor</code> method and with the TrackDependence flag passed to the method set to false. This can be beneficial to avoid false dependences but it requires the users of <code>getAAFor</code> to explicitly record true dependences through this method. The <code>DepClass</code> flag indicates if the dependence is striclty necessary. That means for required dependences, if <code>FromAA</code> changes to an invalid state, <code>ToAA</code> can be moved to a pessimistic fixpoint because it required information from <code>FromAA</code> but none are available anymore. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l01923">1923</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="structllvm_1_1AbstractAttribute.html#a2a637b5d398cbd2f054d4d28fc41d639">llvm::AbstractAttribute::getState()</a>, and <a class="el" href="structllvm_1_1AbstractState.html#adab11027e1a9fdc4c600bb8dba1df413">llvm::AbstractState::isAtFixpoint()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributor_8cpp_source.html#l00535">getAssumedConstant()</a>, <a class="el" href="Attributor_8h_source.html#l01082">getOrCreateAAFor()</a>, <a class="el" href="Attributor_8cpp_source.html#l00611">isAssumedDead()</a>, and <a class="el" href="Attributor_8h_source.html#l01166">lookupAAFor()</a>.</p>

</div>
</div>
<a id="abc1f0f6801f6b71fbd4e610e8ec1c778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1f0f6801f6b71fbd4e610e8ec1c778">&#9670;&nbsp;</a></span>registerAA()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AAType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AAType&amp; llvm::Attributor::registerAA </td>
          <td>(</td>
          <td class="paramtype">AAType &amp;&#160;</td>
          <td class="paramname"><em>AA</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Introduce a new abstract attribute into the fixpoint analysis. </p>
<p>Note that ownership of the attribute is given to the <a class="el" href="structllvm_1_1Attributor.html" title="The fixpoint analysis framework that orchestrates the attribute deduction.">Attributor</a>. It will invoke delete for the <a class="el" href="structllvm_1_1Attributor.html" title="The fixpoint analysis framework that orchestrates the attribute deduction.">Attributor</a> on destruction of the <a class="el" href="structllvm_1_1Attributor.html" title="The fixpoint analysis framework that orchestrates the attribute deduction.">Attributor</a>.</p>
<p>Attributes are identified by their IR position (AAType::getIRPosition()) and the address of their static member (see AAType::ID). </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01212">1212</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Attributor_8h_source.html#l00162">llvm::AADepGraphNode::Deps</a>, <a class="el" href="namespacellvm.html#adadcb655edca867f08f7ea6068a7d8a1aebdf9721be38d1fc1cd6db8c737d1be0">llvm::REQUIRED</a>, and <a class="el" href="Attributor_8h_source.html#l00206">llvm::AADepGraph::SyntheticRoot</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributor_8h_source.html#l01082">getOrCreateAAFor()</a>.</p>

</div>
</div>
<a id="a0121eb7b984a5cf2527133cb838d5982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0121eb7b984a5cf2527133cb838d5982">&#9670;&nbsp;</a></span>registerFunctionSignatureRewrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Attributor::registerFunctionSignatureRewrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Argument.html">Argument</a> &amp;&#160;</td>
          <td class="paramname"><em>Arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt;&#160;</td>
          <td class="paramname"><em>ReplacementTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Attributor_1_1ArgumentReplacementInfo.html#adc6f45669e2fc1a2baa89257c597ee38">ArgumentReplacementInfo::CalleeRepairCBTy</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>CalleeRepairCB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Attributor_1_1ArgumentReplacementInfo.html#a6dd3a0b481598c505e99b524342c88ff">ArgumentReplacementInfo::ACSRepairCBTy</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>ACSRepairCB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classllvm_1_1Register.html" title="Wrapper class representing virtual and physical registers.">Register</a> a rewrite for a function signature. </p>
<p>The argument <code>Arg</code> is replaced with new ones defined by the number, order, and types in <code>ReplacementTypes</code>. The rewiring at the call sites is done through <code>ACSRepairCB</code> and at the callee site through <code>CalleeRepairCB</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>True, if the replacement was registered, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l01597">1597</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="AMDGPULibCalls_8cpp_source.html#l00205">Arg</a>, <a class="el" href="Function_8h_source.html#l00795">llvm::Function::arg_size()</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="SmallVector_8h_source.html#l00073">llvm::SmallVectorBase&lt; Size_T &gt;::empty()</a>, <a class="el" href="Attributor_8cpp_source.html#l01538">isValidFunctionSignatureRewrite()</a>, <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>, <a class="el" href="STLExtras_8h_source.html#l01556">llvm::move()</a>, <a class="el" href="SmallVector_8h_source.html#l00606">llvm::SmallVectorImpl&lt; T &gt;::resize()</a>, and <a class="el" href="ArrayRef_8h_source.html#l00156">llvm::ArrayRef&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a id="a1b7a62e6ac2580f9bc9cbd488d6852a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7a62e6ac2580f9bc9cbd488d6852a2">&#9670;&nbsp;</a></span>registerInvokeWithDeadSuccessor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llvm::Attributor::registerInvokeWithDeadSuccessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InvokeInst.html">InvokeInst</a> &amp;&#160;</td>
          <td class="paramname"><em>II</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classllvm_1_1Record.html">Record</a> that <code>II</code> has at least one dead successor block. </p>
<p>This information is used, e.g., to replace <code>II</code> with a call, after information was manifested. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01320">1320</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

</div>
</div>
<a id="a68190a9c3c6a7ba546fa9cf5e75c22fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68190a9c3c6a7ba546fa9cf5e75c22fa">&#9670;&nbsp;</a></span>removeCallSite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llvm::Attributor::removeCallSite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1CallInst.html">CallInst</a> *&#160;</td>
          <td class="paramname"><em>CI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to remove callsite. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01278">1278</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

<p class="reference">References <a class="el" href="CallGraphUpdater_8cpp_source.html#l00160">llvm::CallGraphUpdater::removeCallSite()</a>.</p>

</div>
</div>
<a id="af7d3babc57be041df699846f65d231c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d3babc57be041df699846f65d231c8">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacellvm.html#acd850975ae5042cacb64a9d0ea4715f3">ChangeStatus</a> Attributor::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the analyses until a fixpoint is reached or enforced (timeout). </p>
<p>The attributes registered with this <a class="el" href="structllvm_1_1Attributor.html" title="The fixpoint analysis framework that orchestrates the attribute deduction.">Attributor</a> can be used after as long as the <a class="el" href="structllvm_1_1Attributor.html" title="The fixpoint analysis framework that orchestrates the attribute deduction.">Attributor</a> is not destroyed (it owns the attributes now).</p>
<p>\Returns CHANGED if the IR was changed, otherwise UNCHANGED. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l01382">1382</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributor_8cpp.html#ab75af9e2df865bde1c9237eed6345507">DumpDepGraph</a>, <a class="el" href="Attributor_8cpp_source.html#l02351">llvm::AADepGraph::dumpGraph()</a>, <a class="el" href="Attributor_8cpp_source.html#l02373">llvm::AADepGraph::print()</a>, <a class="el" href="Attributor_8cpp.html#a7f3685761099c1201793f8c8563f82ce">PrintDependencies</a>, <a class="el" href="Attributor_8cpp.html#ac08c67997914192a8a432ed384063ad9">ViewDepGraph</a>, and <a class="el" href="Attributor_8cpp_source.html#l02349">llvm::AADepGraph::viewGraph()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aeaab50c006df3da87c8813ea0715cecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaab50c006df3da87c8813ea0715cecb">&#9670;&nbsp;</a></span>Allocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacellvm.html#a8e612822d4ba7bb36c9c79582a567108">BumpPtrAllocator</a>&amp; llvm::Attributor::Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The allocator used to allocate memory, e.g. for <code><a class="el" href="structllvm_1_1AbstractAttribute.html" title="Base struct for all &quot;concrete attribute&quot; deductions.">AbstractAttribute</a></code>s. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l01557">1557</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/llvm/Transforms/IPO/<a class="el" href="Attributor_8h_source.html">Attributor.h</a></li>
<li>lib/Transforms/IPO/<a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 9 2021 06:04:41 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
